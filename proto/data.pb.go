// Code generated by protoc-gen-gogo.
// source: data.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = math.Inf

// IsolationType TODO(jiajia) Needs documentation.
type IsolationType int32

const (
	// SERIALIZABLE TODO(jiajia) Needs documentation.
	SERIALIZABLE IsolationType = 0
	// SNAPSHOT TODO(jiajia) Needs documentation.
	SNAPSHOT IsolationType = 1
)

var IsolationType_name = map[int32]string{
	0: "SERIALIZABLE",
	1: "SNAPSHOT",
}
var IsolationType_value = map[string]int32{
	"SERIALIZABLE": 0,
	"SNAPSHOT":     1,
}

func (x IsolationType) Enum() *IsolationType {
	p := new(IsolationType)
	*p = x
	return p
}
func (x IsolationType) String() string {
	return proto1.EnumName(IsolationType_name, int32(x))
}
func (x *IsolationType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(IsolationType_value, data, "IsolationType")
	if err != nil {
		return err
	}
	*x = IsolationType(value)
	return nil
}

// TransactionStatus specifies possible states for a transaction.
type TransactionStatus int32

const (
	// PENDING is the default state for a new transaction. Transactions
	// move from PENDING to one of COMMITTED or ABORTED. Mutations made
	// as part of a PENDING transactions are recorded as "intents" in
	// the underlying MVCC model.
	PENDING TransactionStatus = 0
	// COMMITTED is the state for a transaction which has been
	// committed. Mutations made as part of a transaction which is moved
	// into COMMITTED state become durable and visible to other
	// transactions, moving from "intents" to permanent versioned
	// values.
	COMMITTED TransactionStatus = 1
	// ABORTED is the state for a transaction which has been aborted.
	// Mutations made as part of a transaction which is moved into
	// ABORTED state are deleted and are never made visible to other
	// transactions.
	ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "PENDING",
	1: "COMMITTED",
	2: "ABORTED",
}
var TransactionStatus_value = map[string]int32{
	"PENDING":   0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) Enum() *TransactionStatus {
	p := new(TransactionStatus)
	*p = x
	return p
}
func (x TransactionStatus) String() string {
	return proto1.EnumName(TransactionStatus_name, int32(x))
}
func (x *TransactionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(TransactionStatus_value, data, "TransactionStatus")
	if err != nil {
		return err
	}
	*x = TransactionStatus(value)
	return nil
}

// Timestamp represents a state of the hybrid logical clock.
type Timestamp struct {
	// Holds a wall time, typically a unix epoch time
	// expressed in nanoseconds.
	WallTime int64 `protobuf:"varint,1,opt,name=wall_time" json:"wall_time"`
	// The logical component captures causality for events whose wall
	// times are equal. It is effectively bounded by (maximum clock
	// skew)/(minimal ns between events) and nearly impossible to
	// overflow.
	Logical          int32  `protobuf:"varint,2,opt,name=logical" json:"logical"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Timestamp) Reset()      { *m = Timestamp{} }
func (*Timestamp) ProtoMessage() {}

func (m *Timestamp) GetWallTime() int64 {
	if m != nil {
		return m.WallTime
	}
	return 0
}

func (m *Timestamp) GetLogical() int32 {
	if m != nil {
		return m.Logical
	}
	return 0
}

// Value specifies the value at a key. Multiple values at the same key
// are supported based on timestamp. Values support the union of two
// basic types: a "bag o' bytes" generic byte slice and an incrementable
// int64, for use with the Increment API call.
type Value struct {
	// Bytes is the byte slice value. If this field is set, the integer field
	// should not be.
	Bytes []byte `protobuf:"bytes,1,opt,name=bytes" json:"bytes,omitempty"`
	// Integer is an integer value type. If this field is set, the bytes field
	// should not be. Only Integer values may exist at a key when making the
	// Increment API call.
	Integer *int64 `protobuf:"varint,2,opt,name=integer" json:"integer,omitempty"`
	// Checksum is a CRC-32-IEEE checksum of the key + value, in that order.
	// If this is an integer value, then the value is interpreted as an 8
	// byte, big-endian encoded value. This value is set by the client on
	// writes to do end-to-end integrity verification. If the checksum is
	// incorrect, the write operation will fail. If the client does not
	// wish to use end-to-end checksumming, this value should be nil.
	Checksum *uint32 `protobuf:"fixed32,3,opt,name=checksum" json:"checksum,omitempty"`
	// Timestamp of value.
	Timestamp *Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
	// Tag is an optional string value which can be used to add additional
	// metadata to this value. For example, Tag might provide information on how
	// the bytes in the "bytes" field should be interpreted.
	Tag              *string `protobuf:"bytes,5,opt,name=tag" json:"tag,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto1.CompactTextString(m) }
func (*Value) ProtoMessage()    {}

func (m *Value) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func (m *Value) GetInteger() int64 {
	if m != nil && m.Integer != nil {
		return *m.Integer
	}
	return 0
}

func (m *Value) GetChecksum() uint32 {
	if m != nil && m.Checksum != nil {
		return *m.Checksum
	}
	return 0
}

func (m *Value) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Value) GetTag() string {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return ""
}

// MVCCValue differentiates between normal versioned values and
// deletion tombstones.
type MVCCValue struct {
	// True to indicate a deletion tombstone. If false, value should not
	// be nil.
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted"`
	// The value. Nil if deleted is true; not nil otherwise.
	Value            *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MVCCValue) Reset()         { *m = MVCCValue{} }
func (m *MVCCValue) String() string { return proto1.CompactTextString(m) }
func (*MVCCValue) ProtoMessage()    {}

func (m *MVCCValue) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *MVCCValue) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// KeyValue is a pair of Key and Value for returned Key/Value pairs
// from ScanRequest/ScanResponse. It embeds a Key and a Value.
type KeyValue struct {
	Key              Key    `protobuf:"bytes,1,opt,name=key,customtype=Key" json:"key"`
	Value            Value  `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto1.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}

func (m *KeyValue) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

// RawKeyValue contains the raw bytes of the value for a key.
type RawKeyValue struct {
	Key              EncodedKey `protobuf:"bytes,1,opt,name=key,customtype=EncodedKey" json:"key"`
	Value            []byte     `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *RawKeyValue) Reset()         { *m = RawKeyValue{} }
func (m *RawKeyValue) String() string { return proto1.CompactTextString(m) }
func (*RawKeyValue) ProtoMessage()    {}

func (m *RawKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// A StoreIdent uniquely identifies a store in the cluster. The
// StoreIdent is written to the underlying storage engine at a
// store-reserved system key (KeyLocalIdent).
type StoreIdent struct {
	ClusterID        string  `protobuf:"bytes,1,opt,name=cluster_id" json:"cluster_id"`
	NodeID           NodeID  `protobuf:"varint,2,opt,name=node_id,customtype=NodeID" json:"node_id"`
	StoreID          StoreID `protobuf:"varint,3,opt,name=store_id,customtype=StoreID" json:"store_id"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StoreIdent) Reset()         { *m = StoreIdent{} }
func (m *StoreIdent) String() string { return proto1.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()    {}

func (m *StoreIdent) GetClusterID() string {
	if m != nil {
		return m.ClusterID
	}
	return ""
}

// A SplitTrigger is run after a successful commit of an AdminSplit
// command. It provides the updated range descriptor covering the
// first half of the split and the new range descriptor covering the
// second half. This information allows the final bookkeeping for
// the split to be completed and the new range put into operation.
type SplitTrigger struct {
	UpdatedDesc      RangeDescriptor `protobuf:"bytes,1,opt,name=updated_desc" json:"updated_desc"`
	NewDesc          RangeDescriptor `protobuf:"bytes,2,opt,name=new_desc" json:"new_desc"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *SplitTrigger) Reset()         { *m = SplitTrigger{} }
func (m *SplitTrigger) String() string { return proto1.CompactTextString(m) }
func (*SplitTrigger) ProtoMessage()    {}

func (m *SplitTrigger) GetUpdatedDesc() RangeDescriptor {
	if m != nil {
		return m.UpdatedDesc
	}
	return RangeDescriptor{}
}

func (m *SplitTrigger) GetNewDesc() RangeDescriptor {
	if m != nil {
		return m.NewDesc
	}
	return RangeDescriptor{}
}

// A MergeTrigger is run after a successful commit of an AdminMerge
// command. It provides the updated range descriptor that now encompasses
// what was originally both ranges. This information allows the final bookkeeping
// for the merge to be completed and put into operation.
type MergeTrigger struct {
	UpdatedDesc      RangeDescriptor `protobuf:"bytes,1,opt,name=updated_desc" json:"updated_desc"`
	SubsumedRaftID   int64           `protobuf:"varint,2,opt,name=subsumed_raft_id" json:"subsumed_raft_id"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *MergeTrigger) Reset()         { *m = MergeTrigger{} }
func (m *MergeTrigger) String() string { return proto1.CompactTextString(m) }
func (*MergeTrigger) ProtoMessage()    {}

func (m *MergeTrigger) GetUpdatedDesc() RangeDescriptor {
	if m != nil {
		return m.UpdatedDesc
	}
	return RangeDescriptor{}
}

func (m *MergeTrigger) GetSubsumedRaftID() int64 {
	if m != nil {
		return m.SubsumedRaftID
	}
	return 0
}

// NodeList keeps a growing set of NodeIDs as a sorted slice, with Add()
// adding to the set and Contains() verifying membership.
type NodeList struct {
	// Note that this does not use the NodeID custom type because that appears
	// to interact badly with the repeated and/or packed options.
	Nodes            []int32 `protobuf:"varint,1,rep,packed,name=nodes" json:"nodes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NodeList) Reset()         { *m = NodeList{} }
func (m *NodeList) String() string { return proto1.CompactTextString(m) }
func (*NodeList) ProtoMessage()    {}

func (m *NodeList) GetNodes() []int32 {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// A Transaction is a unit of work performed on the database.
// Cockroach transactions support two isolation levels: snapshot
// isolation and serializable snapshot isolation. Each Cockroach
// transaction is assigned a random priority. This priority will be
// used to decide whether a transaction will be aborted during
// contention.
type Transaction struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Key is the key which anchors the transaction. This is typically
	// the first key read or written during the transaction and
	// determines which range in the cluster will hold the transaction
	// record.
	Key Key `protobuf:"bytes,2,opt,name=key,customtype=Key" json:"key"`
	// ID is a unique UUID value which identifies the transaction.
	ID        []byte            `protobuf:"bytes,3,opt,name=id" json:"id"`
	Priority  int32             `protobuf:"varint,4,opt,name=priority" json:"priority"`
	Isolation IsolationType     `protobuf:"varint,5,opt,name=isolation,enum=proto.IsolationType" json:"isolation"`
	Status    TransactionStatus `protobuf:"varint,6,opt,name=status,enum=proto.TransactionStatus" json:"status"`
	// Incremented on txn retry.
	Epoch int32 `protobuf:"varint,7,opt,name=epoch" json:"epoch"`
	// The last heartbeat timestamp.
	LastHeartbeat *Timestamp `protobuf:"bytes,8,opt,name=last_heartbeat" json:"last_heartbeat,omitempty"`
	// The proposed timestamp for the transaction. This starts as
	// the current wall time on the txn coordinator.
	Timestamp Timestamp `protobuf:"bytes,9,opt,name=timestamp" json:"timestamp"`
	// The original timestamp at which the transaction started. For serializable
	// transactions, if the timestamp drifts from the original timestamp, the
	// transaction will retry.
	OrigTimestamp Timestamp `protobuf:"bytes,10,opt,name=orig_timestamp" json:"orig_timestamp"`
	// Initial Timestamp + clock skew. Reads which encounter values with
	// timestamps between Timestamp and MaxTimestamp trigger a txn
	// retry error, unless the node being read is listed in nodes_read
	// (in which case no more read uncertainty can occur).
	// The case MaxTimestamp < Timestamp is possible for transactions which have
	// been pushed; in this case, MaxTimestamp should be ignored.
	MaxTimestamp Timestamp `protobuf:"bytes,11,opt,name=max_timestamp" json:"max_timestamp"`
	// A sorted list of ids of nodes for which a ReadWithinUncertaintyIntervalError
	// occurred during a prior read. The purpose of keeping this information is
	// that as a reaction to this error, the transaction's timestamp is forwarded
	// appropriately to reflect that node's clock uncertainty. Future reads to
	// the same node are therefore freed from uncertainty restarts.
	//
	// The exact mechanism is that upon encountering the above error, the trans-
	// action will have to retry with a higher timestamp. This higher timestamp
	// is either the one of the encountered future write returned in the error
	// or (if higher, which is in the majority of cases), the time of the node
	// serving the key at the time of the failed read.
	// Additionally storing the node, we make sure to set MaxTimestamp=Timestamp
	// at the time of the read for nodes whose clock we've taken into acount,
	// which amounts to reading without any uncertainty.
	//
	// Bits of this mechanism are found in the local sender, the range and the
	// txn_coord_sender, with brief comments referring here.
	// See https://github.com/cockroachdb/cockroach/pull/221.
	CertainNodes     NodeList `protobuf:"bytes,12,opt,name=certain_nodes" json:"certain_nodes"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Transaction) Reset()      { *m = Transaction{} }
func (*Transaction) ProtoMessage() {}

func (m *Transaction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Transaction) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Transaction) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Transaction) GetIsolation() IsolationType {
	if m != nil {
		return m.Isolation
	}
	return SERIALIZABLE
}

func (m *Transaction) GetStatus() TransactionStatus {
	if m != nil {
		return m.Status
	}
	return PENDING
}

func (m *Transaction) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Transaction) GetLastHeartbeat() *Timestamp {
	if m != nil {
		return m.LastHeartbeat
	}
	return nil
}

func (m *Transaction) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetOrigTimestamp() Timestamp {
	if m != nil {
		return m.OrigTimestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetMaxTimestamp() Timestamp {
	if m != nil {
		return m.MaxTimestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetCertainNodes() NodeList {
	if m != nil {
		return m.CertainNodes
	}
	return NodeList{}
}

// MVCCMetadata holds MVCC metadata for a key. Used by storage/engine/mvcc.go.
type MVCCMetadata struct {
	Txn *Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn,omitempty"`
	// The timestamp of the most recent versioned value.
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
	// Is the most recent value a deletion tombstone?
	Deleted bool `protobuf:"varint,3,opt,name=deleted" json:"deleted"`
	// The size in bytes of the most recent encoded key.
	KeyBytes int64 `protobuf:"varint,4,opt,name=key_bytes" json:"key_bytes"`
	// The size in bytes of the most recent versioned value.
	ValBytes int64 `protobuf:"varint,5,opt,name=val_bytes" json:"val_bytes"`
	// Inline value, used for values with zero timestamp. This provides
	// an efficient short circuit of the normal MVCC metadata sentinel
	// and subsequent version rows. If timestamp == (0, 0), then there
	// is only a single MVCC metadata row with value inlined, and with
	// empty timestamp, key_bytes, and val_bytes.
	Value            *Value `protobuf:"bytes,6,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MVCCMetadata) Reset()         { *m = MVCCMetadata{} }
func (m *MVCCMetadata) String() string { return proto1.CompactTextString(m) }
func (*MVCCMetadata) ProtoMessage()    {}

func (m *MVCCMetadata) GetTxn() *Transaction {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *MVCCMetadata) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *MVCCMetadata) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *MVCCMetadata) GetKeyBytes() int64 {
	if m != nil {
		return m.KeyBytes
	}
	return 0
}

func (m *MVCCMetadata) GetValBytes() int64 {
	if m != nil {
		return m.ValBytes
	}
	return 0
}

func (m *MVCCMetadata) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// ScanMetadata holds information about last complete key/value scan
// of a range.
type ScanMetadata struct {
	// The last scan timestamp in nanoseconds since the Unix epoch.
	LastScanNanos int64 `protobuf:"varint,1,opt,name=last_scan_nanos" json:"last_scan_nanos"`
	// The oldest unresolved write intent in nanoseconds since epoch.
	// Null if there are no unresolved write intents.
	OldestIntentNanos *int64 `protobuf:"varint,2,opt,name=oldest_intent_nanos" json:"oldest_intent_nanos,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *ScanMetadata) Reset()         { *m = ScanMetadata{} }
func (m *ScanMetadata) String() string { return proto1.CompactTextString(m) }
func (*ScanMetadata) ProtoMessage()    {}

func (m *ScanMetadata) GetLastScanNanos() int64 {
	if m != nil {
		return m.LastScanNanos
	}
	return 0
}

func (m *ScanMetadata) GetOldestIntentNanos() int64 {
	if m != nil && m.OldestIntentNanos != nil {
		return *m.OldestIntentNanos
	}
	return 0
}

// TimeSeriesDatapoint is a single point of time series data; a value associated
// with a timestamp.
type TimeSeriesDatapoint struct {
	// The timestamp when this datapoint is located, expressed in nanoseconds
	// since the unix epoch.
	TimestampNanos int64 `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos"`
	// An integer representation of the value of this datapoint. If this field
	// is set, then 'float_value' must not be set.
	IntValue *int64 `protobuf:"varint,2,opt,name=int_value" json:"int_value,omitempty"`
	// A floating point representation of the value of this datapoint. If this
	// field is set, then 'int_value' must not be set.
	FloatValue       *float32 `protobuf:"fixed32,3,opt,name=float_value" json:"float_value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TimeSeriesDatapoint) Reset()         { *m = TimeSeriesDatapoint{} }
func (m *TimeSeriesDatapoint) String() string { return proto1.CompactTextString(m) }
func (*TimeSeriesDatapoint) ProtoMessage()    {}

func (m *TimeSeriesDatapoint) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *TimeSeriesDatapoint) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *TimeSeriesDatapoint) GetFloatValue() float32 {
	if m != nil && m.FloatValue != nil {
		return *m.FloatValue
	}
	return 0
}

// TimeSeriesData is a set of observations of a single variable value at
// multiple points in time. This message contains a string which uniquely
// identifies the source variable, and a repeated set of TimeSeriesDatapoint
// messages representing distinct measurements of that variable.
type TimeSeriesData struct {
	// A string which uniquely identifies the variable from which this data was
	// measured.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Datapoints representing one or more measurements taken from the variable.
	Datapoints       []*TimeSeriesDatapoint `protobuf:"bytes,2,rep,name=datapoints" json:"datapoints,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *TimeSeriesData) Reset()         { *m = TimeSeriesData{} }
func (m *TimeSeriesData) String() string { return proto1.CompactTextString(m) }
func (*TimeSeriesData) ProtoMessage()    {}

func (m *TimeSeriesData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TimeSeriesData) GetDatapoints() []*TimeSeriesDatapoint {
	if m != nil {
		return m.Datapoints
	}
	return nil
}

func init() {
	proto1.RegisterEnum("proto.IsolationType", IsolationType_name, IsolationType_value)
	proto1.RegisterEnum("proto.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
}
