// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: internal.proto

#ifndef PROTOBUF_internal_2eproto__INCLUDED
#define PROTOBUF_internal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "api.pb.h"
#include "config.pb.h"
#include "data.pb.h"
#include "github.com/gogo/protobuf/gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_internal_2eproto();
void protobuf_AssignDesc_internal_2eproto();
void protobuf_ShutdownFile_internal_2eproto();

class InternalRangeLookupRequest;
class InternalRangeLookupResponse;
class InternalHeartbeatTxnRequest;
class InternalHeartbeatTxnResponse;
class InternalGCRequest;
class InternalGCRequest_GCKey;
class InternalGCResponse;
class InternalPushTxnRequest;
class InternalPushTxnResponse;
class InternalResolveIntentRequest;
class InternalResolveIntentResponse;
class InternalMergeRequest;
class InternalMergeResponse;
class InternalTruncateLogRequest;
class InternalTruncateLogResponse;
class ReadWriteCmdResponse;
class InternalRaftCommandUnion;
class InternalRaftCommand;
class InternalTimeSeriesData;
class InternalTimeSeriesSample;

enum InternalValueType {
  _CR_TS = 1
};
bool InternalValueType_IsValid(int value);
const InternalValueType InternalValueType_MIN = _CR_TS;
const InternalValueType InternalValueType_MAX = _CR_TS;
const int InternalValueType_ARRAYSIZE = InternalValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InternalValueType_descriptor();
inline const ::std::string& InternalValueType_Name(InternalValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InternalValueType_descriptor(), value);
}
inline bool InternalValueType_Parse(
    const ::std::string& name, InternalValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalValueType>(
    InternalValueType_descriptor(), name, value);
}
// ===================================================================

class InternalRangeLookupRequest : public ::google::protobuf::Message {
 public:
  InternalRangeLookupRequest();
  virtual ~InternalRangeLookupRequest();

  InternalRangeLookupRequest(const InternalRangeLookupRequest& from);

  inline InternalRangeLookupRequest& operator=(const InternalRangeLookupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRangeLookupRequest& default_instance();

  void Swap(InternalRangeLookupRequest* other);

  // implements Message ----------------------------------------------

  InternalRangeLookupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRangeLookupRequest& from);
  void MergeFrom(const InternalRangeLookupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional int32 max_ranges = 2;
  inline bool has_max_ranges() const;
  inline void clear_max_ranges();
  static const int kMaxRangesFieldNumber = 2;
  inline ::google::protobuf::int32 max_ranges() const;
  inline void set_max_ranges(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.InternalRangeLookupRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_ranges();
  inline void clear_has_max_ranges();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::google::protobuf::int32 max_ranges_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalRangeLookupRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalRangeLookupResponse : public ::google::protobuf::Message {
 public:
  InternalRangeLookupResponse();
  virtual ~InternalRangeLookupResponse();

  InternalRangeLookupResponse(const InternalRangeLookupResponse& from);

  inline InternalRangeLookupResponse& operator=(const InternalRangeLookupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRangeLookupResponse& default_instance();

  void Swap(InternalRangeLookupResponse* other);

  // implements Message ----------------------------------------------

  InternalRangeLookupResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRangeLookupResponse& from);
  void MergeFrom(const InternalRangeLookupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // repeated .proto.RangeDescriptor ranges = 2;
  inline int ranges_size() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 2;
  inline const ::proto::RangeDescriptor& ranges(int index) const;
  inline ::proto::RangeDescriptor* mutable_ranges(int index);
  inline ::proto::RangeDescriptor* add_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::RangeDescriptor >&
      ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::RangeDescriptor >*
      mutable_ranges();

  // @@protoc_insertion_point(class_scope:proto.InternalRangeLookupResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::proto::RangeDescriptor > ranges_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalRangeLookupResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalHeartbeatTxnRequest : public ::google::protobuf::Message {
 public:
  InternalHeartbeatTxnRequest();
  virtual ~InternalHeartbeatTxnRequest();

  InternalHeartbeatTxnRequest(const InternalHeartbeatTxnRequest& from);

  inline InternalHeartbeatTxnRequest& operator=(const InternalHeartbeatTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHeartbeatTxnRequest& default_instance();

  void Swap(InternalHeartbeatTxnRequest* other);

  // implements Message ----------------------------------------------

  InternalHeartbeatTxnRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHeartbeatTxnRequest& from);
  void MergeFrom(const InternalHeartbeatTxnRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:proto.InternalHeartbeatTxnRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalHeartbeatTxnRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalHeartbeatTxnResponse : public ::google::protobuf::Message {
 public:
  InternalHeartbeatTxnResponse();
  virtual ~InternalHeartbeatTxnResponse();

  InternalHeartbeatTxnResponse(const InternalHeartbeatTxnResponse& from);

  inline InternalHeartbeatTxnResponse& operator=(const InternalHeartbeatTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHeartbeatTxnResponse& default_instance();

  void Swap(InternalHeartbeatTxnResponse* other);

  // implements Message ----------------------------------------------

  InternalHeartbeatTxnResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHeartbeatTxnResponse& from);
  void MergeFrom(const InternalHeartbeatTxnResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.InternalHeartbeatTxnResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalHeartbeatTxnResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalGCRequest_GCKey : public ::google::protobuf::Message {
 public:
  InternalGCRequest_GCKey();
  virtual ~InternalGCRequest_GCKey();

  InternalGCRequest_GCKey(const InternalGCRequest_GCKey& from);

  inline InternalGCRequest_GCKey& operator=(const InternalGCRequest_GCKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalGCRequest_GCKey& default_instance();

  void Swap(InternalGCRequest_GCKey* other);

  // implements Message ----------------------------------------------

  InternalGCRequest_GCKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalGCRequest_GCKey& from);
  void MergeFrom(const InternalGCRequest_GCKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .proto.Timestamp timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::proto::Timestamp& timestamp() const;
  inline ::proto::Timestamp* mutable_timestamp();
  inline ::proto::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::proto::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:proto.InternalGCRequest.GCKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::proto::Timestamp* timestamp_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalGCRequest_GCKey* default_instance_;
};
// -------------------------------------------------------------------

class InternalGCRequest : public ::google::protobuf::Message {
 public:
  InternalGCRequest();
  virtual ~InternalGCRequest();

  InternalGCRequest(const InternalGCRequest& from);

  inline InternalGCRequest& operator=(const InternalGCRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalGCRequest& default_instance();

  void Swap(InternalGCRequest* other);

  // implements Message ----------------------------------------------

  InternalGCRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalGCRequest& from);
  void MergeFrom(const InternalGCRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InternalGCRequest_GCKey GCKey;

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional .proto.ScanMetadata scan_meta = 2;
  inline bool has_scan_meta() const;
  inline void clear_scan_meta();
  static const int kScanMetaFieldNumber = 2;
  inline const ::proto::ScanMetadata& scan_meta() const;
  inline ::proto::ScanMetadata* mutable_scan_meta();
  inline ::proto::ScanMetadata* release_scan_meta();
  inline void set_allocated_scan_meta(::proto::ScanMetadata* scan_meta);

  // repeated .proto.InternalGCRequest.GCKey keys = 3;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 3;
  inline const ::proto::InternalGCRequest_GCKey& keys(int index) const;
  inline ::proto::InternalGCRequest_GCKey* mutable_keys(int index);
  inline ::proto::InternalGCRequest_GCKey* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::InternalGCRequest_GCKey >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::InternalGCRequest_GCKey >*
      mutable_keys();

  // @@protoc_insertion_point(class_scope:proto.InternalGCRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_scan_meta();
  inline void clear_has_scan_meta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::ScanMetadata* scan_meta_;
  ::google::protobuf::RepeatedPtrField< ::proto::InternalGCRequest_GCKey > keys_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalGCRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalGCResponse : public ::google::protobuf::Message {
 public:
  InternalGCResponse();
  virtual ~InternalGCResponse();

  InternalGCResponse(const InternalGCResponse& from);

  inline InternalGCResponse& operator=(const InternalGCResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalGCResponse& default_instance();

  void Swap(InternalGCResponse* other);

  // implements Message ----------------------------------------------

  InternalGCResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalGCResponse& from);
  void MergeFrom(const InternalGCResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.InternalGCResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalGCResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalPushTxnRequest : public ::google::protobuf::Message {
 public:
  InternalPushTxnRequest();
  virtual ~InternalPushTxnRequest();

  InternalPushTxnRequest(const InternalPushTxnRequest& from);

  inline InternalPushTxnRequest& operator=(const InternalPushTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalPushTxnRequest& default_instance();

  void Swap(InternalPushTxnRequest* other);

  // implements Message ----------------------------------------------

  InternalPushTxnRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalPushTxnRequest& from);
  void MergeFrom(const InternalPushTxnRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional .proto.Transaction pushee_txn = 2;
  inline bool has_pushee_txn() const;
  inline void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 2;
  inline const ::proto::Transaction& pushee_txn() const;
  inline ::proto::Transaction* mutable_pushee_txn();
  inline ::proto::Transaction* release_pushee_txn();
  inline void set_allocated_pushee_txn(::proto::Transaction* pushee_txn);

  // optional bool Abort = 3;
  inline bool has_abort() const;
  inline void clear_abort();
  static const int kAbortFieldNumber = 3;
  inline bool abort() const;
  inline void set_abort(bool value);

  // @@protoc_insertion_point(class_scope:proto.InternalPushTxnRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pushee_txn();
  inline void clear_has_pushee_txn();
  inline void set_has_abort();
  inline void clear_has_abort();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::Transaction* pushee_txn_;
  bool abort_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalPushTxnRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalPushTxnResponse : public ::google::protobuf::Message {
 public:
  InternalPushTxnResponse();
  virtual ~InternalPushTxnResponse();

  InternalPushTxnResponse(const InternalPushTxnResponse& from);

  inline InternalPushTxnResponse& operator=(const InternalPushTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalPushTxnResponse& default_instance();

  void Swap(InternalPushTxnResponse* other);

  // implements Message ----------------------------------------------

  InternalPushTxnResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalPushTxnResponse& from);
  void MergeFrom(const InternalPushTxnResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // optional .proto.Transaction pushee_txn = 2;
  inline bool has_pushee_txn() const;
  inline void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 2;
  inline const ::proto::Transaction& pushee_txn() const;
  inline ::proto::Transaction* mutable_pushee_txn();
  inline ::proto::Transaction* release_pushee_txn();
  inline void set_allocated_pushee_txn(::proto::Transaction* pushee_txn);

  // @@protoc_insertion_point(class_scope:proto.InternalPushTxnResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pushee_txn();
  inline void clear_has_pushee_txn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::proto::Transaction* pushee_txn_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalPushTxnResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalResolveIntentRequest : public ::google::protobuf::Message {
 public:
  InternalResolveIntentRequest();
  virtual ~InternalResolveIntentRequest();

  InternalResolveIntentRequest(const InternalResolveIntentRequest& from);

  inline InternalResolveIntentRequest& operator=(const InternalResolveIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalResolveIntentRequest& default_instance();

  void Swap(InternalResolveIntentRequest* other);

  // implements Message ----------------------------------------------

  InternalResolveIntentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalResolveIntentRequest& from);
  void MergeFrom(const InternalResolveIntentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:proto.InternalResolveIntentRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalResolveIntentRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalResolveIntentResponse : public ::google::protobuf::Message {
 public:
  InternalResolveIntentResponse();
  virtual ~InternalResolveIntentResponse();

  InternalResolveIntentResponse(const InternalResolveIntentResponse& from);

  inline InternalResolveIntentResponse& operator=(const InternalResolveIntentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalResolveIntentResponse& default_instance();

  void Swap(InternalResolveIntentResponse* other);

  // implements Message ----------------------------------------------

  InternalResolveIntentResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalResolveIntentResponse& from);
  void MergeFrom(const InternalResolveIntentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.InternalResolveIntentResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalResolveIntentResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalMergeRequest : public ::google::protobuf::Message {
 public:
  InternalMergeRequest();
  virtual ~InternalMergeRequest();

  InternalMergeRequest(const InternalMergeRequest& from);

  inline InternalMergeRequest& operator=(const InternalMergeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalMergeRequest& default_instance();

  void Swap(InternalMergeRequest* other);

  // implements Message ----------------------------------------------

  InternalMergeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalMergeRequest& from);
  void MergeFrom(const InternalMergeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional .proto.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::proto::Value& value() const;
  inline ::proto::Value* mutable_value();
  inline ::proto::Value* release_value();
  inline void set_allocated_value(::proto::Value* value);

  // @@protoc_insertion_point(class_scope:proto.InternalMergeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::Value* value_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalMergeRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalMergeResponse : public ::google::protobuf::Message {
 public:
  InternalMergeResponse();
  virtual ~InternalMergeResponse();

  InternalMergeResponse(const InternalMergeResponse& from);

  inline InternalMergeResponse& operator=(const InternalMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalMergeResponse& default_instance();

  void Swap(InternalMergeResponse* other);

  // implements Message ----------------------------------------------

  InternalMergeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalMergeResponse& from);
  void MergeFrom(const InternalMergeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.InternalMergeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalMergeResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalTruncateLogRequest : public ::google::protobuf::Message {
 public:
  InternalTruncateLogRequest();
  virtual ~InternalTruncateLogRequest();

  InternalTruncateLogRequest(const InternalTruncateLogRequest& from);

  inline InternalTruncateLogRequest& operator=(const InternalTruncateLogRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTruncateLogRequest& default_instance();

  void Swap(InternalTruncateLogRequest* other);

  // implements Message ----------------------------------------------

  InternalTruncateLogRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTruncateLogRequest& from);
  void MergeFrom(const InternalTruncateLogRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional uint64 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.InternalTruncateLogRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::google::protobuf::uint64 index_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalTruncateLogRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalTruncateLogResponse : public ::google::protobuf::Message {
 public:
  InternalTruncateLogResponse();
  virtual ~InternalTruncateLogResponse();

  InternalTruncateLogResponse(const InternalTruncateLogResponse& from);

  inline InternalTruncateLogResponse& operator=(const InternalTruncateLogResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTruncateLogResponse& default_instance();

  void Swap(InternalTruncateLogResponse* other);

  // implements Message ----------------------------------------------

  InternalTruncateLogResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTruncateLogResponse& from);
  void MergeFrom(const InternalTruncateLogResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.InternalTruncateLogResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalTruncateLogResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReadWriteCmdResponse : public ::google::protobuf::Message {
 public:
  ReadWriteCmdResponse();
  virtual ~ReadWriteCmdResponse();

  ReadWriteCmdResponse(const ReadWriteCmdResponse& from);

  inline ReadWriteCmdResponse& operator=(const ReadWriteCmdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadWriteCmdResponse& default_instance();

  void Swap(ReadWriteCmdResponse* other);

  // implements Message ----------------------------------------------

  ReadWriteCmdResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadWriteCmdResponse& from);
  void MergeFrom(const ReadWriteCmdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.PutResponse put = 1;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 1;
  inline const ::proto::PutResponse& put() const;
  inline ::proto::PutResponse* mutable_put();
  inline ::proto::PutResponse* release_put();
  inline void set_allocated_put(::proto::PutResponse* put);

  // optional .proto.ConditionalPutResponse conditional_put = 2;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 2;
  inline const ::proto::ConditionalPutResponse& conditional_put() const;
  inline ::proto::ConditionalPutResponse* mutable_conditional_put();
  inline ::proto::ConditionalPutResponse* release_conditional_put();
  inline void set_allocated_conditional_put(::proto::ConditionalPutResponse* conditional_put);

  // optional .proto.IncrementResponse increment = 3;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 3;
  inline const ::proto::IncrementResponse& increment() const;
  inline ::proto::IncrementResponse* mutable_increment();
  inline ::proto::IncrementResponse* release_increment();
  inline void set_allocated_increment(::proto::IncrementResponse* increment);

  // optional .proto.DeleteResponse delete = 4;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 4;
  inline const ::proto::DeleteResponse& delete_() const;
  inline ::proto::DeleteResponse* mutable_delete_();
  inline ::proto::DeleteResponse* release_delete_();
  inline void set_allocated_delete_(::proto::DeleteResponse* delete_);

  // optional .proto.DeleteRangeResponse delete_range = 5;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 5;
  inline const ::proto::DeleteRangeResponse& delete_range() const;
  inline ::proto::DeleteRangeResponse* mutable_delete_range();
  inline ::proto::DeleteRangeResponse* release_delete_range();
  inline void set_allocated_delete_range(::proto::DeleteRangeResponse* delete_range);

  // optional .proto.EndTransactionResponse end_transaction = 6;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 6;
  inline const ::proto::EndTransactionResponse& end_transaction() const;
  inline ::proto::EndTransactionResponse* mutable_end_transaction();
  inline ::proto::EndTransactionResponse* release_end_transaction();
  inline void set_allocated_end_transaction(::proto::EndTransactionResponse* end_transaction);

  // optional .proto.ReapQueueResponse reap_queue = 7;
  inline bool has_reap_queue() const;
  inline void clear_reap_queue();
  static const int kReapQueueFieldNumber = 7;
  inline const ::proto::ReapQueueResponse& reap_queue() const;
  inline ::proto::ReapQueueResponse* mutable_reap_queue();
  inline ::proto::ReapQueueResponse* release_reap_queue();
  inline void set_allocated_reap_queue(::proto::ReapQueueResponse* reap_queue);

  // optional .proto.EnqueueUpdateResponse enqueue_update = 8;
  inline bool has_enqueue_update() const;
  inline void clear_enqueue_update();
  static const int kEnqueueUpdateFieldNumber = 8;
  inline const ::proto::EnqueueUpdateResponse& enqueue_update() const;
  inline ::proto::EnqueueUpdateResponse* mutable_enqueue_update();
  inline ::proto::EnqueueUpdateResponse* release_enqueue_update();
  inline void set_allocated_enqueue_update(::proto::EnqueueUpdateResponse* enqueue_update);

  // optional .proto.EnqueueMessageResponse enqueue_message = 9;
  inline bool has_enqueue_message() const;
  inline void clear_enqueue_message();
  static const int kEnqueueMessageFieldNumber = 9;
  inline const ::proto::EnqueueMessageResponse& enqueue_message() const;
  inline ::proto::EnqueueMessageResponse* mutable_enqueue_message();
  inline ::proto::EnqueueMessageResponse* release_enqueue_message();
  inline void set_allocated_enqueue_message(::proto::EnqueueMessageResponse* enqueue_message);

  // optional .proto.InternalHeartbeatTxnResponse internal_heartbeat_txn = 10;
  inline bool has_internal_heartbeat_txn() const;
  inline void clear_internal_heartbeat_txn();
  static const int kInternalHeartbeatTxnFieldNumber = 10;
  inline const ::proto::InternalHeartbeatTxnResponse& internal_heartbeat_txn() const;
  inline ::proto::InternalHeartbeatTxnResponse* mutable_internal_heartbeat_txn();
  inline ::proto::InternalHeartbeatTxnResponse* release_internal_heartbeat_txn();
  inline void set_allocated_internal_heartbeat_txn(::proto::InternalHeartbeatTxnResponse* internal_heartbeat_txn);

  // optional .proto.InternalPushTxnResponse internal_push_txn = 11;
  inline bool has_internal_push_txn() const;
  inline void clear_internal_push_txn();
  static const int kInternalPushTxnFieldNumber = 11;
  inline const ::proto::InternalPushTxnResponse& internal_push_txn() const;
  inline ::proto::InternalPushTxnResponse* mutable_internal_push_txn();
  inline ::proto::InternalPushTxnResponse* release_internal_push_txn();
  inline void set_allocated_internal_push_txn(::proto::InternalPushTxnResponse* internal_push_txn);

  // optional .proto.InternalResolveIntentResponse internal_resolve_intent = 12;
  inline bool has_internal_resolve_intent() const;
  inline void clear_internal_resolve_intent();
  static const int kInternalResolveIntentFieldNumber = 12;
  inline const ::proto::InternalResolveIntentResponse& internal_resolve_intent() const;
  inline ::proto::InternalResolveIntentResponse* mutable_internal_resolve_intent();
  inline ::proto::InternalResolveIntentResponse* release_internal_resolve_intent();
  inline void set_allocated_internal_resolve_intent(::proto::InternalResolveIntentResponse* internal_resolve_intent);

  // optional .proto.InternalMergeResponse internal_merge = 13;
  inline bool has_internal_merge() const;
  inline void clear_internal_merge();
  static const int kInternalMergeFieldNumber = 13;
  inline const ::proto::InternalMergeResponse& internal_merge() const;
  inline ::proto::InternalMergeResponse* mutable_internal_merge();
  inline ::proto::InternalMergeResponse* release_internal_merge();
  inline void set_allocated_internal_merge(::proto::InternalMergeResponse* internal_merge);

  // optional .proto.InternalTruncateLogResponse internal_truncate_log = 14;
  inline bool has_internal_truncate_log() const;
  inline void clear_internal_truncate_log();
  static const int kInternalTruncateLogFieldNumber = 14;
  inline const ::proto::InternalTruncateLogResponse& internal_truncate_log() const;
  inline ::proto::InternalTruncateLogResponse* mutable_internal_truncate_log();
  inline ::proto::InternalTruncateLogResponse* release_internal_truncate_log();
  inline void set_allocated_internal_truncate_log(::proto::InternalTruncateLogResponse* internal_truncate_log);

  // optional .proto.InternalGCResponse internal_gc = 15;
  inline bool has_internal_gc() const;
  inline void clear_internal_gc();
  static const int kInternalGcFieldNumber = 15;
  inline const ::proto::InternalGCResponse& internal_gc() const;
  inline ::proto::InternalGCResponse* mutable_internal_gc();
  inline ::proto::InternalGCResponse* release_internal_gc();
  inline void set_allocated_internal_gc(::proto::InternalGCResponse* internal_gc);

  // @@protoc_insertion_point(class_scope:proto.ReadWriteCmdResponse)
 private:
  inline void set_has_put();
  inline void clear_has_put();
  inline void set_has_conditional_put();
  inline void clear_has_conditional_put();
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_delete_range();
  inline void clear_has_delete_range();
  inline void set_has_end_transaction();
  inline void clear_has_end_transaction();
  inline void set_has_reap_queue();
  inline void clear_has_reap_queue();
  inline void set_has_enqueue_update();
  inline void clear_has_enqueue_update();
  inline void set_has_enqueue_message();
  inline void clear_has_enqueue_message();
  inline void set_has_internal_heartbeat_txn();
  inline void clear_has_internal_heartbeat_txn();
  inline void set_has_internal_push_txn();
  inline void clear_has_internal_push_txn();
  inline void set_has_internal_resolve_intent();
  inline void clear_has_internal_resolve_intent();
  inline void set_has_internal_merge();
  inline void clear_has_internal_merge();
  inline void set_has_internal_truncate_log();
  inline void clear_has_internal_truncate_log();
  inline void set_has_internal_gc();
  inline void clear_has_internal_gc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::PutResponse* put_;
  ::proto::ConditionalPutResponse* conditional_put_;
  ::proto::IncrementResponse* increment_;
  ::proto::DeleteResponse* delete__;
  ::proto::DeleteRangeResponse* delete_range_;
  ::proto::EndTransactionResponse* end_transaction_;
  ::proto::ReapQueueResponse* reap_queue_;
  ::proto::EnqueueUpdateResponse* enqueue_update_;
  ::proto::EnqueueMessageResponse* enqueue_message_;
  ::proto::InternalHeartbeatTxnResponse* internal_heartbeat_txn_;
  ::proto::InternalPushTxnResponse* internal_push_txn_;
  ::proto::InternalResolveIntentResponse* internal_resolve_intent_;
  ::proto::InternalMergeResponse* internal_merge_;
  ::proto::InternalTruncateLogResponse* internal_truncate_log_;
  ::proto::InternalGCResponse* internal_gc_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static ReadWriteCmdResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalRaftCommandUnion : public ::google::protobuf::Message {
 public:
  InternalRaftCommandUnion();
  virtual ~InternalRaftCommandUnion();

  InternalRaftCommandUnion(const InternalRaftCommandUnion& from);

  inline InternalRaftCommandUnion& operator=(const InternalRaftCommandUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRaftCommandUnion& default_instance();

  void Swap(InternalRaftCommandUnion* other);

  // implements Message ----------------------------------------------

  InternalRaftCommandUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRaftCommandUnion& from);
  void MergeFrom(const InternalRaftCommandUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ContainsRequest contains = 1;
  inline bool has_contains() const;
  inline void clear_contains();
  static const int kContainsFieldNumber = 1;
  inline const ::proto::ContainsRequest& contains() const;
  inline ::proto::ContainsRequest* mutable_contains();
  inline ::proto::ContainsRequest* release_contains();
  inline void set_allocated_contains(::proto::ContainsRequest* contains);

  // optional .proto.GetRequest get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline const ::proto::GetRequest& get() const;
  inline ::proto::GetRequest* mutable_get();
  inline ::proto::GetRequest* release_get();
  inline void set_allocated_get(::proto::GetRequest* get);

  // optional .proto.PutRequest put = 3;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 3;
  inline const ::proto::PutRequest& put() const;
  inline ::proto::PutRequest* mutable_put();
  inline ::proto::PutRequest* release_put();
  inline void set_allocated_put(::proto::PutRequest* put);

  // optional .proto.ConditionalPutRequest conditional_put = 4;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 4;
  inline const ::proto::ConditionalPutRequest& conditional_put() const;
  inline ::proto::ConditionalPutRequest* mutable_conditional_put();
  inline ::proto::ConditionalPutRequest* release_conditional_put();
  inline void set_allocated_conditional_put(::proto::ConditionalPutRequest* conditional_put);

  // optional .proto.IncrementRequest increment = 5;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 5;
  inline const ::proto::IncrementRequest& increment() const;
  inline ::proto::IncrementRequest* mutable_increment();
  inline ::proto::IncrementRequest* release_increment();
  inline void set_allocated_increment(::proto::IncrementRequest* increment);

  // optional .proto.DeleteRequest delete = 6;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 6;
  inline const ::proto::DeleteRequest& delete_() const;
  inline ::proto::DeleteRequest* mutable_delete_();
  inline ::proto::DeleteRequest* release_delete_();
  inline void set_allocated_delete_(::proto::DeleteRequest* delete_);

  // optional .proto.DeleteRangeRequest delete_range = 7;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 7;
  inline const ::proto::DeleteRangeRequest& delete_range() const;
  inline ::proto::DeleteRangeRequest* mutable_delete_range();
  inline ::proto::DeleteRangeRequest* release_delete_range();
  inline void set_allocated_delete_range(::proto::DeleteRangeRequest* delete_range);

  // optional .proto.ScanRequest scan = 8;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 8;
  inline const ::proto::ScanRequest& scan() const;
  inline ::proto::ScanRequest* mutable_scan();
  inline ::proto::ScanRequest* release_scan();
  inline void set_allocated_scan(::proto::ScanRequest* scan);

  // optional .proto.EndTransactionRequest end_transaction = 9;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  inline const ::proto::EndTransactionRequest& end_transaction() const;
  inline ::proto::EndTransactionRequest* mutable_end_transaction();
  inline ::proto::EndTransactionRequest* release_end_transaction();
  inline void set_allocated_end_transaction(::proto::EndTransactionRequest* end_transaction);

  // optional .proto.ReapQueueRequest reap_queue = 10;
  inline bool has_reap_queue() const;
  inline void clear_reap_queue();
  static const int kReapQueueFieldNumber = 10;
  inline const ::proto::ReapQueueRequest& reap_queue() const;
  inline ::proto::ReapQueueRequest* mutable_reap_queue();
  inline ::proto::ReapQueueRequest* release_reap_queue();
  inline void set_allocated_reap_queue(::proto::ReapQueueRequest* reap_queue);

  // optional .proto.EnqueueUpdateRequest enqueue_update = 11;
  inline bool has_enqueue_update() const;
  inline void clear_enqueue_update();
  static const int kEnqueueUpdateFieldNumber = 11;
  inline const ::proto::EnqueueUpdateRequest& enqueue_update() const;
  inline ::proto::EnqueueUpdateRequest* mutable_enqueue_update();
  inline ::proto::EnqueueUpdateRequest* release_enqueue_update();
  inline void set_allocated_enqueue_update(::proto::EnqueueUpdateRequest* enqueue_update);

  // optional .proto.EnqueueMessageRequest enqueue_message = 12;
  inline bool has_enqueue_message() const;
  inline void clear_enqueue_message();
  static const int kEnqueueMessageFieldNumber = 12;
  inline const ::proto::EnqueueMessageRequest& enqueue_message() const;
  inline ::proto::EnqueueMessageRequest* mutable_enqueue_message();
  inline ::proto::EnqueueMessageRequest* release_enqueue_message();
  inline void set_allocated_enqueue_message(::proto::EnqueueMessageRequest* enqueue_message);

  // optional .proto.BatchRequest batch = 30;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 30;
  inline const ::proto::BatchRequest& batch() const;
  inline ::proto::BatchRequest* mutable_batch();
  inline ::proto::BatchRequest* release_batch();
  inline void set_allocated_batch(::proto::BatchRequest* batch);

  // optional .proto.InternalRangeLookupRequest internal_range_lookup = 31;
  inline bool has_internal_range_lookup() const;
  inline void clear_internal_range_lookup();
  static const int kInternalRangeLookupFieldNumber = 31;
  inline const ::proto::InternalRangeLookupRequest& internal_range_lookup() const;
  inline ::proto::InternalRangeLookupRequest* mutable_internal_range_lookup();
  inline ::proto::InternalRangeLookupRequest* release_internal_range_lookup();
  inline void set_allocated_internal_range_lookup(::proto::InternalRangeLookupRequest* internal_range_lookup);

  // optional .proto.InternalHeartbeatTxnRequest internal_heartbeat_txn = 32;
  inline bool has_internal_heartbeat_txn() const;
  inline void clear_internal_heartbeat_txn();
  static const int kInternalHeartbeatTxnFieldNumber = 32;
  inline const ::proto::InternalHeartbeatTxnRequest& internal_heartbeat_txn() const;
  inline ::proto::InternalHeartbeatTxnRequest* mutable_internal_heartbeat_txn();
  inline ::proto::InternalHeartbeatTxnRequest* release_internal_heartbeat_txn();
  inline void set_allocated_internal_heartbeat_txn(::proto::InternalHeartbeatTxnRequest* internal_heartbeat_txn);

  // optional .proto.InternalPushTxnRequest internal_push_txn = 33;
  inline bool has_internal_push_txn() const;
  inline void clear_internal_push_txn();
  static const int kInternalPushTxnFieldNumber = 33;
  inline const ::proto::InternalPushTxnRequest& internal_push_txn() const;
  inline ::proto::InternalPushTxnRequest* mutable_internal_push_txn();
  inline ::proto::InternalPushTxnRequest* release_internal_push_txn();
  inline void set_allocated_internal_push_txn(::proto::InternalPushTxnRequest* internal_push_txn);

  // optional .proto.InternalResolveIntentRequest internal_resolve_intent = 34;
  inline bool has_internal_resolve_intent() const;
  inline void clear_internal_resolve_intent();
  static const int kInternalResolveIntentFieldNumber = 34;
  inline const ::proto::InternalResolveIntentRequest& internal_resolve_intent() const;
  inline ::proto::InternalResolveIntentRequest* mutable_internal_resolve_intent();
  inline ::proto::InternalResolveIntentRequest* release_internal_resolve_intent();
  inline void set_allocated_internal_resolve_intent(::proto::InternalResolveIntentRequest* internal_resolve_intent);

  // optional .proto.InternalMergeRequest internal_merge_response = 35;
  inline bool has_internal_merge_response() const;
  inline void clear_internal_merge_response();
  static const int kInternalMergeResponseFieldNumber = 35;
  inline const ::proto::InternalMergeRequest& internal_merge_response() const;
  inline ::proto::InternalMergeRequest* mutable_internal_merge_response();
  inline ::proto::InternalMergeRequest* release_internal_merge_response();
  inline void set_allocated_internal_merge_response(::proto::InternalMergeRequest* internal_merge_response);

  // optional .proto.InternalTruncateLogRequest internal_truncate_log = 36;
  inline bool has_internal_truncate_log() const;
  inline void clear_internal_truncate_log();
  static const int kInternalTruncateLogFieldNumber = 36;
  inline const ::proto::InternalTruncateLogRequest& internal_truncate_log() const;
  inline ::proto::InternalTruncateLogRequest* mutable_internal_truncate_log();
  inline ::proto::InternalTruncateLogRequest* release_internal_truncate_log();
  inline void set_allocated_internal_truncate_log(::proto::InternalTruncateLogRequest* internal_truncate_log);

  // optional .proto.InternalGCRequest internal_gc = 37;
  inline bool has_internal_gc() const;
  inline void clear_internal_gc();
  static const int kInternalGcFieldNumber = 37;
  inline const ::proto::InternalGCRequest& internal_gc() const;
  inline ::proto::InternalGCRequest* mutable_internal_gc();
  inline ::proto::InternalGCRequest* release_internal_gc();
  inline void set_allocated_internal_gc(::proto::InternalGCRequest* internal_gc);

  // @@protoc_insertion_point(class_scope:proto.InternalRaftCommandUnion)
 private:
  inline void set_has_contains();
  inline void clear_has_contains();
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_put();
  inline void clear_has_put();
  inline void set_has_conditional_put();
  inline void clear_has_conditional_put();
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_delete_range();
  inline void clear_has_delete_range();
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_end_transaction();
  inline void clear_has_end_transaction();
  inline void set_has_reap_queue();
  inline void clear_has_reap_queue();
  inline void set_has_enqueue_update();
  inline void clear_has_enqueue_update();
  inline void set_has_enqueue_message();
  inline void clear_has_enqueue_message();
  inline void set_has_batch();
  inline void clear_has_batch();
  inline void set_has_internal_range_lookup();
  inline void clear_has_internal_range_lookup();
  inline void set_has_internal_heartbeat_txn();
  inline void clear_has_internal_heartbeat_txn();
  inline void set_has_internal_push_txn();
  inline void clear_has_internal_push_txn();
  inline void set_has_internal_resolve_intent();
  inline void clear_has_internal_resolve_intent();
  inline void set_has_internal_merge_response();
  inline void clear_has_internal_merge_response();
  inline void set_has_internal_truncate_log();
  inline void clear_has_internal_truncate_log();
  inline void set_has_internal_gc();
  inline void clear_has_internal_gc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ContainsRequest* contains_;
  ::proto::GetRequest* get_;
  ::proto::PutRequest* put_;
  ::proto::ConditionalPutRequest* conditional_put_;
  ::proto::IncrementRequest* increment_;
  ::proto::DeleteRequest* delete__;
  ::proto::DeleteRangeRequest* delete_range_;
  ::proto::ScanRequest* scan_;
  ::proto::EndTransactionRequest* end_transaction_;
  ::proto::ReapQueueRequest* reap_queue_;
  ::proto::EnqueueUpdateRequest* enqueue_update_;
  ::proto::EnqueueMessageRequest* enqueue_message_;
  ::proto::BatchRequest* batch_;
  ::proto::InternalRangeLookupRequest* internal_range_lookup_;
  ::proto::InternalHeartbeatTxnRequest* internal_heartbeat_txn_;
  ::proto::InternalPushTxnRequest* internal_push_txn_;
  ::proto::InternalResolveIntentRequest* internal_resolve_intent_;
  ::proto::InternalMergeRequest* internal_merge_response_;
  ::proto::InternalTruncateLogRequest* internal_truncate_log_;
  ::proto::InternalGCRequest* internal_gc_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalRaftCommandUnion* default_instance_;
};
// -------------------------------------------------------------------

class InternalRaftCommand : public ::google::protobuf::Message {
 public:
  InternalRaftCommand();
  virtual ~InternalRaftCommand();

  InternalRaftCommand(const InternalRaftCommand& from);

  inline InternalRaftCommand& operator=(const InternalRaftCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRaftCommand& default_instance();

  void Swap(InternalRaftCommand* other);

  // implements Message ----------------------------------------------

  InternalRaftCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRaftCommand& from);
  void MergeFrom(const InternalRaftCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 raft_id = 2;
  inline bool has_raft_id() const;
  inline void clear_raft_id();
  static const int kRaftIdFieldNumber = 2;
  inline ::google::protobuf::int64 raft_id() const;
  inline void set_raft_id(::google::protobuf::int64 value);

  // optional .proto.InternalRaftCommandUnion cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline const ::proto::InternalRaftCommandUnion& cmd() const;
  inline ::proto::InternalRaftCommandUnion* mutable_cmd();
  inline ::proto::InternalRaftCommandUnion* release_cmd();
  inline void set_allocated_cmd(::proto::InternalRaftCommandUnion* cmd);

  // @@protoc_insertion_point(class_scope:proto.InternalRaftCommand)
 private:
  inline void set_has_raft_id();
  inline void clear_has_raft_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 raft_id_;
  ::proto::InternalRaftCommandUnion* cmd_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalRaftCommand* default_instance_;
};
// -------------------------------------------------------------------

class InternalTimeSeriesData : public ::google::protobuf::Message {
 public:
  InternalTimeSeriesData();
  virtual ~InternalTimeSeriesData();

  InternalTimeSeriesData(const InternalTimeSeriesData& from);

  inline InternalTimeSeriesData& operator=(const InternalTimeSeriesData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTimeSeriesData& default_instance();

  void Swap(InternalTimeSeriesData* other);

  // implements Message ----------------------------------------------

  InternalTimeSeriesData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTimeSeriesData& from);
  void MergeFrom(const InternalTimeSeriesData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 start_timestamp_nanos = 1;
  inline bool has_start_timestamp_nanos() const;
  inline void clear_start_timestamp_nanos();
  static const int kStartTimestampNanosFieldNumber = 1;
  inline ::google::protobuf::int64 start_timestamp_nanos() const;
  inline void set_start_timestamp_nanos(::google::protobuf::int64 value);

  // optional int64 sample_duration_nanos = 2;
  inline bool has_sample_duration_nanos() const;
  inline void clear_sample_duration_nanos();
  static const int kSampleDurationNanosFieldNumber = 2;
  inline ::google::protobuf::int64 sample_duration_nanos() const;
  inline void set_sample_duration_nanos(::google::protobuf::int64 value);

  // repeated .proto.InternalTimeSeriesSample samples = 3;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 3;
  inline const ::proto::InternalTimeSeriesSample& samples(int index) const;
  inline ::proto::InternalTimeSeriesSample* mutable_samples(int index);
  inline ::proto::InternalTimeSeriesSample* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::InternalTimeSeriesSample >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::InternalTimeSeriesSample >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:proto.InternalTimeSeriesData)
 private:
  inline void set_has_start_timestamp_nanos();
  inline void clear_has_start_timestamp_nanos();
  inline void set_has_sample_duration_nanos();
  inline void clear_has_sample_duration_nanos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 start_timestamp_nanos_;
  ::google::protobuf::int64 sample_duration_nanos_;
  ::google::protobuf::RepeatedPtrField< ::proto::InternalTimeSeriesSample > samples_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalTimeSeriesData* default_instance_;
};
// -------------------------------------------------------------------

class InternalTimeSeriesSample : public ::google::protobuf::Message {
 public:
  InternalTimeSeriesSample();
  virtual ~InternalTimeSeriesSample();

  InternalTimeSeriesSample(const InternalTimeSeriesSample& from);

  inline InternalTimeSeriesSample& operator=(const InternalTimeSeriesSample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTimeSeriesSample& default_instance();

  void Swap(InternalTimeSeriesSample* other);

  // implements Message ----------------------------------------------

  InternalTimeSeriesSample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTimeSeriesSample& from);
  void MergeFrom(const InternalTimeSeriesSample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional uint32 int_count = 2;
  inline bool has_int_count() const;
  inline void clear_int_count();
  static const int kIntCountFieldNumber = 2;
  inline ::google::protobuf::uint32 int_count() const;
  inline void set_int_count(::google::protobuf::uint32 value);

  // optional int64 int_sum = 3;
  inline bool has_int_sum() const;
  inline void clear_int_sum();
  static const int kIntSumFieldNumber = 3;
  inline ::google::protobuf::int64 int_sum() const;
  inline void set_int_sum(::google::protobuf::int64 value);

  // optional int64 int_max = 4;
  inline bool has_int_max() const;
  inline void clear_int_max();
  static const int kIntMaxFieldNumber = 4;
  inline ::google::protobuf::int64 int_max() const;
  inline void set_int_max(::google::protobuf::int64 value);

  // optional int64 int_min = 5;
  inline bool has_int_min() const;
  inline void clear_int_min();
  static const int kIntMinFieldNumber = 5;
  inline ::google::protobuf::int64 int_min() const;
  inline void set_int_min(::google::protobuf::int64 value);

  // optional uint32 float_count = 6;
  inline bool has_float_count() const;
  inline void clear_float_count();
  static const int kFloatCountFieldNumber = 6;
  inline ::google::protobuf::uint32 float_count() const;
  inline void set_float_count(::google::protobuf::uint32 value);

  // optional float float_sum = 7;
  inline bool has_float_sum() const;
  inline void clear_float_sum();
  static const int kFloatSumFieldNumber = 7;
  inline float float_sum() const;
  inline void set_float_sum(float value);

  // optional float float_max = 8;
  inline bool has_float_max() const;
  inline void clear_float_max();
  static const int kFloatMaxFieldNumber = 8;
  inline float float_max() const;
  inline void set_float_max(float value);

  // optional float float_min = 9;
  inline bool has_float_min() const;
  inline void clear_float_min();
  static const int kFloatMinFieldNumber = 9;
  inline float float_min() const;
  inline void set_float_min(float value);

  // @@protoc_insertion_point(class_scope:proto.InternalTimeSeriesSample)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_int_count();
  inline void clear_has_int_count();
  inline void set_has_int_sum();
  inline void clear_has_int_sum();
  inline void set_has_int_max();
  inline void clear_has_int_max();
  inline void set_has_int_min();
  inline void clear_has_int_min();
  inline void set_has_float_count();
  inline void clear_has_float_count();
  inline void set_has_float_sum();
  inline void clear_has_float_sum();
  inline void set_has_float_max();
  inline void clear_has_float_max();
  inline void set_has_float_min();
  inline void clear_has_float_min();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::uint32 int_count_;
  ::google::protobuf::int64 int_sum_;
  ::google::protobuf::int64 int_max_;
  ::google::protobuf::int64 int_min_;
  ::google::protobuf::uint32 float_count_;
  float float_sum_;
  float float_max_;
  float float_min_;
  friend void  protobuf_AddDesc_internal_2eproto();
  friend void protobuf_AssignDesc_internal_2eproto();
  friend void protobuf_ShutdownFile_internal_2eproto();

  void InitAsDefaultInstance();
  static InternalTimeSeriesSample* default_instance_;
};
// ===================================================================


// ===================================================================

// InternalRangeLookupRequest

// optional .proto.RequestHeader header = 1;
inline bool InternalRangeLookupRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRangeLookupRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRangeLookupRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRangeLookupRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& InternalRangeLookupRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalRangeLookupRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* InternalRangeLookupRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalRangeLookupRequest.header)
  return header_;
}
inline ::proto::RequestHeader* InternalRangeLookupRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalRangeLookupRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRangeLookupRequest.header)
}

// optional int32 max_ranges = 2;
inline bool InternalRangeLookupRequest::has_max_ranges() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalRangeLookupRequest::set_has_max_ranges() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalRangeLookupRequest::clear_has_max_ranges() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalRangeLookupRequest::clear_max_ranges() {
  max_ranges_ = 0;
  clear_has_max_ranges();
}
inline ::google::protobuf::int32 InternalRangeLookupRequest::max_ranges() const {
  // @@protoc_insertion_point(field_get:proto.InternalRangeLookupRequest.max_ranges)
  return max_ranges_;
}
inline void InternalRangeLookupRequest::set_max_ranges(::google::protobuf::int32 value) {
  set_has_max_ranges();
  max_ranges_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalRangeLookupRequest.max_ranges)
}

// -------------------------------------------------------------------

// InternalRangeLookupResponse

// optional .proto.ResponseHeader header = 1;
inline bool InternalRangeLookupResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRangeLookupResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRangeLookupResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRangeLookupResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& InternalRangeLookupResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalRangeLookupResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* InternalRangeLookupResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalRangeLookupResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* InternalRangeLookupResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalRangeLookupResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRangeLookupResponse.header)
}

// repeated .proto.RangeDescriptor ranges = 2;
inline int InternalRangeLookupResponse::ranges_size() const {
  return ranges_.size();
}
inline void InternalRangeLookupResponse::clear_ranges() {
  ranges_.Clear();
}
inline const ::proto::RangeDescriptor& InternalRangeLookupResponse::ranges(int index) const {
  // @@protoc_insertion_point(field_get:proto.InternalRangeLookupResponse.ranges)
  return ranges_.Get(index);
}
inline ::proto::RangeDescriptor* InternalRangeLookupResponse::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:proto.InternalRangeLookupResponse.ranges)
  return ranges_.Mutable(index);
}
inline ::proto::RangeDescriptor* InternalRangeLookupResponse::add_ranges() {
  // @@protoc_insertion_point(field_add:proto.InternalRangeLookupResponse.ranges)
  return ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::RangeDescriptor >&
InternalRangeLookupResponse::ranges() const {
  // @@protoc_insertion_point(field_list:proto.InternalRangeLookupResponse.ranges)
  return ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::RangeDescriptor >*
InternalRangeLookupResponse::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:proto.InternalRangeLookupResponse.ranges)
  return &ranges_;
}

// -------------------------------------------------------------------

// InternalHeartbeatTxnRequest

// optional .proto.RequestHeader header = 1;
inline bool InternalHeartbeatTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHeartbeatTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHeartbeatTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHeartbeatTxnRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& InternalHeartbeatTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalHeartbeatTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* InternalHeartbeatTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalHeartbeatTxnRequest.header)
  return header_;
}
inline ::proto::RequestHeader* InternalHeartbeatTxnRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalHeartbeatTxnRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalHeartbeatTxnRequest.header)
}

// -------------------------------------------------------------------

// InternalHeartbeatTxnResponse

// optional .proto.ResponseHeader header = 1;
inline bool InternalHeartbeatTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHeartbeatTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHeartbeatTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHeartbeatTxnResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& InternalHeartbeatTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalHeartbeatTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* InternalHeartbeatTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalHeartbeatTxnResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* InternalHeartbeatTxnResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalHeartbeatTxnResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalHeartbeatTxnResponse.header)
}

// -------------------------------------------------------------------

// InternalGCRequest_GCKey

// optional bytes key = 1;
inline bool InternalGCRequest_GCKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalGCRequest_GCKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalGCRequest_GCKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalGCRequest_GCKey::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& InternalGCRequest_GCKey::key() const {
  // @@protoc_insertion_point(field_get:proto.InternalGCRequest.GCKey.key)
  return *key_;
}
inline void InternalGCRequest_GCKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.InternalGCRequest.GCKey.key)
}
inline void InternalGCRequest_GCKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.InternalGCRequest.GCKey.key)
}
inline void InternalGCRequest_GCKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.InternalGCRequest.GCKey.key)
}
inline ::std::string* InternalGCRequest_GCKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.InternalGCRequest.GCKey.key)
  return key_;
}
inline ::std::string* InternalGCRequest_GCKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InternalGCRequest_GCKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalGCRequest.GCKey.key)
}

// optional .proto.Timestamp timestamp = 2;
inline bool InternalGCRequest_GCKey::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalGCRequest_GCKey::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalGCRequest_GCKey::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalGCRequest_GCKey::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::proto::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::proto::Timestamp& InternalGCRequest_GCKey::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.InternalGCRequest.GCKey.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::proto::Timestamp* InternalGCRequest_GCKey::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:proto.InternalGCRequest.GCKey.timestamp)
  return timestamp_;
}
inline ::proto::Timestamp* InternalGCRequest_GCKey::release_timestamp() {
  clear_has_timestamp();
  ::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void InternalGCRequest_GCKey::set_allocated_timestamp(::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalGCRequest.GCKey.timestamp)
}

// -------------------------------------------------------------------

// InternalGCRequest

// optional .proto.RequestHeader header = 1;
inline bool InternalGCRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalGCRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalGCRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalGCRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& InternalGCRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalGCRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* InternalGCRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalGCRequest.header)
  return header_;
}
inline ::proto::RequestHeader* InternalGCRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalGCRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalGCRequest.header)
}

// optional .proto.ScanMetadata scan_meta = 2;
inline bool InternalGCRequest::has_scan_meta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalGCRequest::set_has_scan_meta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalGCRequest::clear_has_scan_meta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalGCRequest::clear_scan_meta() {
  if (scan_meta_ != NULL) scan_meta_->::proto::ScanMetadata::Clear();
  clear_has_scan_meta();
}
inline const ::proto::ScanMetadata& InternalGCRequest::scan_meta() const {
  // @@protoc_insertion_point(field_get:proto.InternalGCRequest.scan_meta)
  return scan_meta_ != NULL ? *scan_meta_ : *default_instance_->scan_meta_;
}
inline ::proto::ScanMetadata* InternalGCRequest::mutable_scan_meta() {
  set_has_scan_meta();
  if (scan_meta_ == NULL) scan_meta_ = new ::proto::ScanMetadata;
  // @@protoc_insertion_point(field_mutable:proto.InternalGCRequest.scan_meta)
  return scan_meta_;
}
inline ::proto::ScanMetadata* InternalGCRequest::release_scan_meta() {
  clear_has_scan_meta();
  ::proto::ScanMetadata* temp = scan_meta_;
  scan_meta_ = NULL;
  return temp;
}
inline void InternalGCRequest::set_allocated_scan_meta(::proto::ScanMetadata* scan_meta) {
  delete scan_meta_;
  scan_meta_ = scan_meta;
  if (scan_meta) {
    set_has_scan_meta();
  } else {
    clear_has_scan_meta();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalGCRequest.scan_meta)
}

// repeated .proto.InternalGCRequest.GCKey keys = 3;
inline int InternalGCRequest::keys_size() const {
  return keys_.size();
}
inline void InternalGCRequest::clear_keys() {
  keys_.Clear();
}
inline const ::proto::InternalGCRequest_GCKey& InternalGCRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:proto.InternalGCRequest.keys)
  return keys_.Get(index);
}
inline ::proto::InternalGCRequest_GCKey* InternalGCRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:proto.InternalGCRequest.keys)
  return keys_.Mutable(index);
}
inline ::proto::InternalGCRequest_GCKey* InternalGCRequest::add_keys() {
  // @@protoc_insertion_point(field_add:proto.InternalGCRequest.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::InternalGCRequest_GCKey >&
InternalGCRequest::keys() const {
  // @@protoc_insertion_point(field_list:proto.InternalGCRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::InternalGCRequest_GCKey >*
InternalGCRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:proto.InternalGCRequest.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// InternalGCResponse

// optional .proto.ResponseHeader header = 1;
inline bool InternalGCResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalGCResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalGCResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalGCResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& InternalGCResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalGCResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* InternalGCResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalGCResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* InternalGCResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalGCResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalGCResponse.header)
}

// -------------------------------------------------------------------

// InternalPushTxnRequest

// optional .proto.RequestHeader header = 1;
inline bool InternalPushTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalPushTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalPushTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalPushTxnRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& InternalPushTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalPushTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* InternalPushTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalPushTxnRequest.header)
  return header_;
}
inline ::proto::RequestHeader* InternalPushTxnRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalPushTxnRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalPushTxnRequest.header)
}

// optional .proto.Transaction pushee_txn = 2;
inline bool InternalPushTxnRequest::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalPushTxnRequest::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalPushTxnRequest::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalPushTxnRequest::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
inline const ::proto::Transaction& InternalPushTxnRequest::pushee_txn() const {
  // @@protoc_insertion_point(field_get:proto.InternalPushTxnRequest.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
inline ::proto::Transaction* InternalPushTxnRequest::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) pushee_txn_ = new ::proto::Transaction;
  // @@protoc_insertion_point(field_mutable:proto.InternalPushTxnRequest.pushee_txn)
  return pushee_txn_;
}
inline ::proto::Transaction* InternalPushTxnRequest::release_pushee_txn() {
  clear_has_pushee_txn();
  ::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline void InternalPushTxnRequest::set_allocated_pushee_txn(::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalPushTxnRequest.pushee_txn)
}

// optional bool Abort = 3;
inline bool InternalPushTxnRequest::has_abort() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalPushTxnRequest::set_has_abort() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalPushTxnRequest::clear_has_abort() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalPushTxnRequest::clear_abort() {
  abort_ = false;
  clear_has_abort();
}
inline bool InternalPushTxnRequest::abort() const {
  // @@protoc_insertion_point(field_get:proto.InternalPushTxnRequest.Abort)
  return abort_;
}
inline void InternalPushTxnRequest::set_abort(bool value) {
  set_has_abort();
  abort_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalPushTxnRequest.Abort)
}

// -------------------------------------------------------------------

// InternalPushTxnResponse

// optional .proto.ResponseHeader header = 1;
inline bool InternalPushTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalPushTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalPushTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalPushTxnResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& InternalPushTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalPushTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* InternalPushTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalPushTxnResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* InternalPushTxnResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalPushTxnResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalPushTxnResponse.header)
}

// optional .proto.Transaction pushee_txn = 2;
inline bool InternalPushTxnResponse::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalPushTxnResponse::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalPushTxnResponse::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalPushTxnResponse::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
inline const ::proto::Transaction& InternalPushTxnResponse::pushee_txn() const {
  // @@protoc_insertion_point(field_get:proto.InternalPushTxnResponse.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
inline ::proto::Transaction* InternalPushTxnResponse::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) pushee_txn_ = new ::proto::Transaction;
  // @@protoc_insertion_point(field_mutable:proto.InternalPushTxnResponse.pushee_txn)
  return pushee_txn_;
}
inline ::proto::Transaction* InternalPushTxnResponse::release_pushee_txn() {
  clear_has_pushee_txn();
  ::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline void InternalPushTxnResponse::set_allocated_pushee_txn(::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalPushTxnResponse.pushee_txn)
}

// -------------------------------------------------------------------

// InternalResolveIntentRequest

// optional .proto.RequestHeader header = 1;
inline bool InternalResolveIntentRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalResolveIntentRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalResolveIntentRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalResolveIntentRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& InternalResolveIntentRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalResolveIntentRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* InternalResolveIntentRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalResolveIntentRequest.header)
  return header_;
}
inline ::proto::RequestHeader* InternalResolveIntentRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalResolveIntentRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalResolveIntentRequest.header)
}

// -------------------------------------------------------------------

// InternalResolveIntentResponse

// optional .proto.ResponseHeader header = 1;
inline bool InternalResolveIntentResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalResolveIntentResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalResolveIntentResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalResolveIntentResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& InternalResolveIntentResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalResolveIntentResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* InternalResolveIntentResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalResolveIntentResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* InternalResolveIntentResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalResolveIntentResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalResolveIntentResponse.header)
}

// -------------------------------------------------------------------

// InternalMergeRequest

// optional .proto.RequestHeader header = 1;
inline bool InternalMergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalMergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalMergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalMergeRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& InternalMergeRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalMergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* InternalMergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalMergeRequest.header)
  return header_;
}
inline ::proto::RequestHeader* InternalMergeRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalMergeRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalMergeRequest.header)
}

// optional .proto.Value value = 2;
inline bool InternalMergeRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalMergeRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalMergeRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalMergeRequest::clear_value() {
  if (value_ != NULL) value_->::proto::Value::Clear();
  clear_has_value();
}
inline const ::proto::Value& InternalMergeRequest::value() const {
  // @@protoc_insertion_point(field_get:proto.InternalMergeRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::proto::Value* InternalMergeRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::proto::Value;
  // @@protoc_insertion_point(field_mutable:proto.InternalMergeRequest.value)
  return value_;
}
inline ::proto::Value* InternalMergeRequest::release_value() {
  clear_has_value();
  ::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void InternalMergeRequest::set_allocated_value(::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalMergeRequest.value)
}

// -------------------------------------------------------------------

// InternalMergeResponse

// optional .proto.ResponseHeader header = 1;
inline bool InternalMergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalMergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalMergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalMergeResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& InternalMergeResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalMergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* InternalMergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalMergeResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* InternalMergeResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalMergeResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalMergeResponse.header)
}

// -------------------------------------------------------------------

// InternalTruncateLogRequest

// optional .proto.RequestHeader header = 1;
inline bool InternalTruncateLogRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTruncateLogRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTruncateLogRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTruncateLogRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& InternalTruncateLogRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalTruncateLogRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* InternalTruncateLogRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalTruncateLogRequest.header)
  return header_;
}
inline ::proto::RequestHeader* InternalTruncateLogRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalTruncateLogRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalTruncateLogRequest.header)
}

// optional uint64 index = 2;
inline bool InternalTruncateLogRequest::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTruncateLogRequest::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTruncateLogRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTruncateLogRequest::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 InternalTruncateLogRequest::index() const {
  // @@protoc_insertion_point(field_get:proto.InternalTruncateLogRequest.index)
  return index_;
}
inline void InternalTruncateLogRequest::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTruncateLogRequest.index)
}

// -------------------------------------------------------------------

// InternalTruncateLogResponse

// optional .proto.ResponseHeader header = 1;
inline bool InternalTruncateLogResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTruncateLogResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTruncateLogResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTruncateLogResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& InternalTruncateLogResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.InternalTruncateLogResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* InternalTruncateLogResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.InternalTruncateLogResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* InternalTruncateLogResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalTruncateLogResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalTruncateLogResponse.header)
}

// -------------------------------------------------------------------

// ReadWriteCmdResponse

// optional .proto.PutResponse put = 1;
inline bool ReadWriteCmdResponse::has_put() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadWriteCmdResponse::set_has_put() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadWriteCmdResponse::clear_has_put() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadWriteCmdResponse::clear_put() {
  if (put_ != NULL) put_->::proto::PutResponse::Clear();
  clear_has_put();
}
inline const ::proto::PutResponse& ReadWriteCmdResponse::put() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::proto::PutResponse* ReadWriteCmdResponse::mutable_put() {
  set_has_put();
  if (put_ == NULL) put_ = new ::proto::PutResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.put)
  return put_;
}
inline ::proto::PutResponse* ReadWriteCmdResponse::release_put() {
  clear_has_put();
  ::proto::PutResponse* temp = put_;
  put_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_put(::proto::PutResponse* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.put)
}

// optional .proto.ConditionalPutResponse conditional_put = 2;
inline bool ReadWriteCmdResponse::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadWriteCmdResponse::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadWriteCmdResponse::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadWriteCmdResponse::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::proto::ConditionalPutResponse::Clear();
  clear_has_conditional_put();
}
inline const ::proto::ConditionalPutResponse& ReadWriteCmdResponse::conditional_put() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
inline ::proto::ConditionalPutResponse* ReadWriteCmdResponse::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) conditional_put_ = new ::proto::ConditionalPutResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.conditional_put)
  return conditional_put_;
}
inline ::proto::ConditionalPutResponse* ReadWriteCmdResponse::release_conditional_put() {
  clear_has_conditional_put();
  ::proto::ConditionalPutResponse* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_conditional_put(::proto::ConditionalPutResponse* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.conditional_put)
}

// optional .proto.IncrementResponse increment = 3;
inline bool ReadWriteCmdResponse::has_increment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReadWriteCmdResponse::set_has_increment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReadWriteCmdResponse::clear_has_increment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReadWriteCmdResponse::clear_increment() {
  if (increment_ != NULL) increment_->::proto::IncrementResponse::Clear();
  clear_has_increment();
}
inline const ::proto::IncrementResponse& ReadWriteCmdResponse::increment() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
inline ::proto::IncrementResponse* ReadWriteCmdResponse::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) increment_ = new ::proto::IncrementResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.increment)
  return increment_;
}
inline ::proto::IncrementResponse* ReadWriteCmdResponse::release_increment() {
  clear_has_increment();
  ::proto::IncrementResponse* temp = increment_;
  increment_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_increment(::proto::IncrementResponse* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.increment)
}

// optional .proto.DeleteResponse delete = 4;
inline bool ReadWriteCmdResponse::has_delete_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReadWriteCmdResponse::set_has_delete_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReadWriteCmdResponse::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReadWriteCmdResponse::clear_delete_() {
  if (delete__ != NULL) delete__->::proto::DeleteResponse::Clear();
  clear_has_delete_();
}
inline const ::proto::DeleteResponse& ReadWriteCmdResponse::delete_() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::proto::DeleteResponse* ReadWriteCmdResponse::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) delete__ = new ::proto::DeleteResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.delete)
  return delete__;
}
inline ::proto::DeleteResponse* ReadWriteCmdResponse::release_delete_() {
  clear_has_delete_();
  ::proto::DeleteResponse* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_delete_(::proto::DeleteResponse* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.delete)
}

// optional .proto.DeleteRangeResponse delete_range = 5;
inline bool ReadWriteCmdResponse::has_delete_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReadWriteCmdResponse::set_has_delete_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReadWriteCmdResponse::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReadWriteCmdResponse::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::proto::DeleteRangeResponse::Clear();
  clear_has_delete_range();
}
inline const ::proto::DeleteRangeResponse& ReadWriteCmdResponse::delete_range() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
inline ::proto::DeleteRangeResponse* ReadWriteCmdResponse::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) delete_range_ = new ::proto::DeleteRangeResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.delete_range)
  return delete_range_;
}
inline ::proto::DeleteRangeResponse* ReadWriteCmdResponse::release_delete_range() {
  clear_has_delete_range();
  ::proto::DeleteRangeResponse* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_delete_range(::proto::DeleteRangeResponse* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.delete_range)
}

// optional .proto.EndTransactionResponse end_transaction = 6;
inline bool ReadWriteCmdResponse::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReadWriteCmdResponse::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReadWriteCmdResponse::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReadWriteCmdResponse::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::proto::EndTransactionResponse::Clear();
  clear_has_end_transaction();
}
inline const ::proto::EndTransactionResponse& ReadWriteCmdResponse::end_transaction() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
inline ::proto::EndTransactionResponse* ReadWriteCmdResponse::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) end_transaction_ = new ::proto::EndTransactionResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.end_transaction)
  return end_transaction_;
}
inline ::proto::EndTransactionResponse* ReadWriteCmdResponse::release_end_transaction() {
  clear_has_end_transaction();
  ::proto::EndTransactionResponse* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_end_transaction(::proto::EndTransactionResponse* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.end_transaction)
}

// optional .proto.ReapQueueResponse reap_queue = 7;
inline bool ReadWriteCmdResponse::has_reap_queue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReadWriteCmdResponse::set_has_reap_queue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReadWriteCmdResponse::clear_has_reap_queue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReadWriteCmdResponse::clear_reap_queue() {
  if (reap_queue_ != NULL) reap_queue_->::proto::ReapQueueResponse::Clear();
  clear_has_reap_queue();
}
inline const ::proto::ReapQueueResponse& ReadWriteCmdResponse::reap_queue() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.reap_queue)
  return reap_queue_ != NULL ? *reap_queue_ : *default_instance_->reap_queue_;
}
inline ::proto::ReapQueueResponse* ReadWriteCmdResponse::mutable_reap_queue() {
  set_has_reap_queue();
  if (reap_queue_ == NULL) reap_queue_ = new ::proto::ReapQueueResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.reap_queue)
  return reap_queue_;
}
inline ::proto::ReapQueueResponse* ReadWriteCmdResponse::release_reap_queue() {
  clear_has_reap_queue();
  ::proto::ReapQueueResponse* temp = reap_queue_;
  reap_queue_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_reap_queue(::proto::ReapQueueResponse* reap_queue) {
  delete reap_queue_;
  reap_queue_ = reap_queue;
  if (reap_queue) {
    set_has_reap_queue();
  } else {
    clear_has_reap_queue();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.reap_queue)
}

// optional .proto.EnqueueUpdateResponse enqueue_update = 8;
inline bool ReadWriteCmdResponse::has_enqueue_update() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReadWriteCmdResponse::set_has_enqueue_update() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReadWriteCmdResponse::clear_has_enqueue_update() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReadWriteCmdResponse::clear_enqueue_update() {
  if (enqueue_update_ != NULL) enqueue_update_->::proto::EnqueueUpdateResponse::Clear();
  clear_has_enqueue_update();
}
inline const ::proto::EnqueueUpdateResponse& ReadWriteCmdResponse::enqueue_update() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.enqueue_update)
  return enqueue_update_ != NULL ? *enqueue_update_ : *default_instance_->enqueue_update_;
}
inline ::proto::EnqueueUpdateResponse* ReadWriteCmdResponse::mutable_enqueue_update() {
  set_has_enqueue_update();
  if (enqueue_update_ == NULL) enqueue_update_ = new ::proto::EnqueueUpdateResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.enqueue_update)
  return enqueue_update_;
}
inline ::proto::EnqueueUpdateResponse* ReadWriteCmdResponse::release_enqueue_update() {
  clear_has_enqueue_update();
  ::proto::EnqueueUpdateResponse* temp = enqueue_update_;
  enqueue_update_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_enqueue_update(::proto::EnqueueUpdateResponse* enqueue_update) {
  delete enqueue_update_;
  enqueue_update_ = enqueue_update;
  if (enqueue_update) {
    set_has_enqueue_update();
  } else {
    clear_has_enqueue_update();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.enqueue_update)
}

// optional .proto.EnqueueMessageResponse enqueue_message = 9;
inline bool ReadWriteCmdResponse::has_enqueue_message() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReadWriteCmdResponse::set_has_enqueue_message() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReadWriteCmdResponse::clear_has_enqueue_message() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReadWriteCmdResponse::clear_enqueue_message() {
  if (enqueue_message_ != NULL) enqueue_message_->::proto::EnqueueMessageResponse::Clear();
  clear_has_enqueue_message();
}
inline const ::proto::EnqueueMessageResponse& ReadWriteCmdResponse::enqueue_message() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.enqueue_message)
  return enqueue_message_ != NULL ? *enqueue_message_ : *default_instance_->enqueue_message_;
}
inline ::proto::EnqueueMessageResponse* ReadWriteCmdResponse::mutable_enqueue_message() {
  set_has_enqueue_message();
  if (enqueue_message_ == NULL) enqueue_message_ = new ::proto::EnqueueMessageResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.enqueue_message)
  return enqueue_message_;
}
inline ::proto::EnqueueMessageResponse* ReadWriteCmdResponse::release_enqueue_message() {
  clear_has_enqueue_message();
  ::proto::EnqueueMessageResponse* temp = enqueue_message_;
  enqueue_message_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_enqueue_message(::proto::EnqueueMessageResponse* enqueue_message) {
  delete enqueue_message_;
  enqueue_message_ = enqueue_message;
  if (enqueue_message) {
    set_has_enqueue_message();
  } else {
    clear_has_enqueue_message();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.enqueue_message)
}

// optional .proto.InternalHeartbeatTxnResponse internal_heartbeat_txn = 10;
inline bool ReadWriteCmdResponse::has_internal_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReadWriteCmdResponse::set_has_internal_heartbeat_txn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReadWriteCmdResponse::clear_has_internal_heartbeat_txn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReadWriteCmdResponse::clear_internal_heartbeat_txn() {
  if (internal_heartbeat_txn_ != NULL) internal_heartbeat_txn_->::proto::InternalHeartbeatTxnResponse::Clear();
  clear_has_internal_heartbeat_txn();
}
inline const ::proto::InternalHeartbeatTxnResponse& ReadWriteCmdResponse::internal_heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.internal_heartbeat_txn)
  return internal_heartbeat_txn_ != NULL ? *internal_heartbeat_txn_ : *default_instance_->internal_heartbeat_txn_;
}
inline ::proto::InternalHeartbeatTxnResponse* ReadWriteCmdResponse::mutable_internal_heartbeat_txn() {
  set_has_internal_heartbeat_txn();
  if (internal_heartbeat_txn_ == NULL) internal_heartbeat_txn_ = new ::proto::InternalHeartbeatTxnResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.internal_heartbeat_txn)
  return internal_heartbeat_txn_;
}
inline ::proto::InternalHeartbeatTxnResponse* ReadWriteCmdResponse::release_internal_heartbeat_txn() {
  clear_has_internal_heartbeat_txn();
  ::proto::InternalHeartbeatTxnResponse* temp = internal_heartbeat_txn_;
  internal_heartbeat_txn_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_internal_heartbeat_txn(::proto::InternalHeartbeatTxnResponse* internal_heartbeat_txn) {
  delete internal_heartbeat_txn_;
  internal_heartbeat_txn_ = internal_heartbeat_txn;
  if (internal_heartbeat_txn) {
    set_has_internal_heartbeat_txn();
  } else {
    clear_has_internal_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.internal_heartbeat_txn)
}

// optional .proto.InternalPushTxnResponse internal_push_txn = 11;
inline bool ReadWriteCmdResponse::has_internal_push_txn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReadWriteCmdResponse::set_has_internal_push_txn() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReadWriteCmdResponse::clear_has_internal_push_txn() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReadWriteCmdResponse::clear_internal_push_txn() {
  if (internal_push_txn_ != NULL) internal_push_txn_->::proto::InternalPushTxnResponse::Clear();
  clear_has_internal_push_txn();
}
inline const ::proto::InternalPushTxnResponse& ReadWriteCmdResponse::internal_push_txn() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.internal_push_txn)
  return internal_push_txn_ != NULL ? *internal_push_txn_ : *default_instance_->internal_push_txn_;
}
inline ::proto::InternalPushTxnResponse* ReadWriteCmdResponse::mutable_internal_push_txn() {
  set_has_internal_push_txn();
  if (internal_push_txn_ == NULL) internal_push_txn_ = new ::proto::InternalPushTxnResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.internal_push_txn)
  return internal_push_txn_;
}
inline ::proto::InternalPushTxnResponse* ReadWriteCmdResponse::release_internal_push_txn() {
  clear_has_internal_push_txn();
  ::proto::InternalPushTxnResponse* temp = internal_push_txn_;
  internal_push_txn_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_internal_push_txn(::proto::InternalPushTxnResponse* internal_push_txn) {
  delete internal_push_txn_;
  internal_push_txn_ = internal_push_txn;
  if (internal_push_txn) {
    set_has_internal_push_txn();
  } else {
    clear_has_internal_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.internal_push_txn)
}

// optional .proto.InternalResolveIntentResponse internal_resolve_intent = 12;
inline bool ReadWriteCmdResponse::has_internal_resolve_intent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ReadWriteCmdResponse::set_has_internal_resolve_intent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ReadWriteCmdResponse::clear_has_internal_resolve_intent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ReadWriteCmdResponse::clear_internal_resolve_intent() {
  if (internal_resolve_intent_ != NULL) internal_resolve_intent_->::proto::InternalResolveIntentResponse::Clear();
  clear_has_internal_resolve_intent();
}
inline const ::proto::InternalResolveIntentResponse& ReadWriteCmdResponse::internal_resolve_intent() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.internal_resolve_intent)
  return internal_resolve_intent_ != NULL ? *internal_resolve_intent_ : *default_instance_->internal_resolve_intent_;
}
inline ::proto::InternalResolveIntentResponse* ReadWriteCmdResponse::mutable_internal_resolve_intent() {
  set_has_internal_resolve_intent();
  if (internal_resolve_intent_ == NULL) internal_resolve_intent_ = new ::proto::InternalResolveIntentResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.internal_resolve_intent)
  return internal_resolve_intent_;
}
inline ::proto::InternalResolveIntentResponse* ReadWriteCmdResponse::release_internal_resolve_intent() {
  clear_has_internal_resolve_intent();
  ::proto::InternalResolveIntentResponse* temp = internal_resolve_intent_;
  internal_resolve_intent_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_internal_resolve_intent(::proto::InternalResolveIntentResponse* internal_resolve_intent) {
  delete internal_resolve_intent_;
  internal_resolve_intent_ = internal_resolve_intent;
  if (internal_resolve_intent) {
    set_has_internal_resolve_intent();
  } else {
    clear_has_internal_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.internal_resolve_intent)
}

// optional .proto.InternalMergeResponse internal_merge = 13;
inline bool ReadWriteCmdResponse::has_internal_merge() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ReadWriteCmdResponse::set_has_internal_merge() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ReadWriteCmdResponse::clear_has_internal_merge() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ReadWriteCmdResponse::clear_internal_merge() {
  if (internal_merge_ != NULL) internal_merge_->::proto::InternalMergeResponse::Clear();
  clear_has_internal_merge();
}
inline const ::proto::InternalMergeResponse& ReadWriteCmdResponse::internal_merge() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.internal_merge)
  return internal_merge_ != NULL ? *internal_merge_ : *default_instance_->internal_merge_;
}
inline ::proto::InternalMergeResponse* ReadWriteCmdResponse::mutable_internal_merge() {
  set_has_internal_merge();
  if (internal_merge_ == NULL) internal_merge_ = new ::proto::InternalMergeResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.internal_merge)
  return internal_merge_;
}
inline ::proto::InternalMergeResponse* ReadWriteCmdResponse::release_internal_merge() {
  clear_has_internal_merge();
  ::proto::InternalMergeResponse* temp = internal_merge_;
  internal_merge_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_internal_merge(::proto::InternalMergeResponse* internal_merge) {
  delete internal_merge_;
  internal_merge_ = internal_merge;
  if (internal_merge) {
    set_has_internal_merge();
  } else {
    clear_has_internal_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.internal_merge)
}

// optional .proto.InternalTruncateLogResponse internal_truncate_log = 14;
inline bool ReadWriteCmdResponse::has_internal_truncate_log() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ReadWriteCmdResponse::set_has_internal_truncate_log() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ReadWriteCmdResponse::clear_has_internal_truncate_log() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ReadWriteCmdResponse::clear_internal_truncate_log() {
  if (internal_truncate_log_ != NULL) internal_truncate_log_->::proto::InternalTruncateLogResponse::Clear();
  clear_has_internal_truncate_log();
}
inline const ::proto::InternalTruncateLogResponse& ReadWriteCmdResponse::internal_truncate_log() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.internal_truncate_log)
  return internal_truncate_log_ != NULL ? *internal_truncate_log_ : *default_instance_->internal_truncate_log_;
}
inline ::proto::InternalTruncateLogResponse* ReadWriteCmdResponse::mutable_internal_truncate_log() {
  set_has_internal_truncate_log();
  if (internal_truncate_log_ == NULL) internal_truncate_log_ = new ::proto::InternalTruncateLogResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.internal_truncate_log)
  return internal_truncate_log_;
}
inline ::proto::InternalTruncateLogResponse* ReadWriteCmdResponse::release_internal_truncate_log() {
  clear_has_internal_truncate_log();
  ::proto::InternalTruncateLogResponse* temp = internal_truncate_log_;
  internal_truncate_log_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_internal_truncate_log(::proto::InternalTruncateLogResponse* internal_truncate_log) {
  delete internal_truncate_log_;
  internal_truncate_log_ = internal_truncate_log;
  if (internal_truncate_log) {
    set_has_internal_truncate_log();
  } else {
    clear_has_internal_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.internal_truncate_log)
}

// optional .proto.InternalGCResponse internal_gc = 15;
inline bool ReadWriteCmdResponse::has_internal_gc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ReadWriteCmdResponse::set_has_internal_gc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ReadWriteCmdResponse::clear_has_internal_gc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ReadWriteCmdResponse::clear_internal_gc() {
  if (internal_gc_ != NULL) internal_gc_->::proto::InternalGCResponse::Clear();
  clear_has_internal_gc();
}
inline const ::proto::InternalGCResponse& ReadWriteCmdResponse::internal_gc() const {
  // @@protoc_insertion_point(field_get:proto.ReadWriteCmdResponse.internal_gc)
  return internal_gc_ != NULL ? *internal_gc_ : *default_instance_->internal_gc_;
}
inline ::proto::InternalGCResponse* ReadWriteCmdResponse::mutable_internal_gc() {
  set_has_internal_gc();
  if (internal_gc_ == NULL) internal_gc_ = new ::proto::InternalGCResponse;
  // @@protoc_insertion_point(field_mutable:proto.ReadWriteCmdResponse.internal_gc)
  return internal_gc_;
}
inline ::proto::InternalGCResponse* ReadWriteCmdResponse::release_internal_gc() {
  clear_has_internal_gc();
  ::proto::InternalGCResponse* temp = internal_gc_;
  internal_gc_ = NULL;
  return temp;
}
inline void ReadWriteCmdResponse::set_allocated_internal_gc(::proto::InternalGCResponse* internal_gc) {
  delete internal_gc_;
  internal_gc_ = internal_gc;
  if (internal_gc) {
    set_has_internal_gc();
  } else {
    clear_has_internal_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReadWriteCmdResponse.internal_gc)
}

// -------------------------------------------------------------------

// InternalRaftCommandUnion

// optional .proto.ContainsRequest contains = 1;
inline bool InternalRaftCommandUnion::has_contains() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRaftCommandUnion::set_has_contains() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRaftCommandUnion::clear_has_contains() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRaftCommandUnion::clear_contains() {
  if (contains_ != NULL) contains_->::proto::ContainsRequest::Clear();
  clear_has_contains();
}
inline const ::proto::ContainsRequest& InternalRaftCommandUnion::contains() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.contains)
  return contains_ != NULL ? *contains_ : *default_instance_->contains_;
}
inline ::proto::ContainsRequest* InternalRaftCommandUnion::mutable_contains() {
  set_has_contains();
  if (contains_ == NULL) contains_ = new ::proto::ContainsRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.contains)
  return contains_;
}
inline ::proto::ContainsRequest* InternalRaftCommandUnion::release_contains() {
  clear_has_contains();
  ::proto::ContainsRequest* temp = contains_;
  contains_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_contains(::proto::ContainsRequest* contains) {
  delete contains_;
  contains_ = contains;
  if (contains) {
    set_has_contains();
  } else {
    clear_has_contains();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.contains)
}

// optional .proto.GetRequest get = 2;
inline bool InternalRaftCommandUnion::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalRaftCommandUnion::set_has_get() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalRaftCommandUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalRaftCommandUnion::clear_get() {
  if (get_ != NULL) get_->::proto::GetRequest::Clear();
  clear_has_get();
}
inline const ::proto::GetRequest& InternalRaftCommandUnion::get() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::proto::GetRequest* InternalRaftCommandUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) get_ = new ::proto::GetRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.get)
  return get_;
}
inline ::proto::GetRequest* InternalRaftCommandUnion::release_get() {
  clear_has_get();
  ::proto::GetRequest* temp = get_;
  get_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_get(::proto::GetRequest* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.get)
}

// optional .proto.PutRequest put = 3;
inline bool InternalRaftCommandUnion::has_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalRaftCommandUnion::set_has_put() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalRaftCommandUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalRaftCommandUnion::clear_put() {
  if (put_ != NULL) put_->::proto::PutRequest::Clear();
  clear_has_put();
}
inline const ::proto::PutRequest& InternalRaftCommandUnion::put() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::proto::PutRequest* InternalRaftCommandUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) put_ = new ::proto::PutRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.put)
  return put_;
}
inline ::proto::PutRequest* InternalRaftCommandUnion::release_put() {
  clear_has_put();
  ::proto::PutRequest* temp = put_;
  put_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_put(::proto::PutRequest* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.put)
}

// optional .proto.ConditionalPutRequest conditional_put = 4;
inline bool InternalRaftCommandUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalRaftCommandUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalRaftCommandUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalRaftCommandUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::proto::ConditionalPutRequest::Clear();
  clear_has_conditional_put();
}
inline const ::proto::ConditionalPutRequest& InternalRaftCommandUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
inline ::proto::ConditionalPutRequest* InternalRaftCommandUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) conditional_put_ = new ::proto::ConditionalPutRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.conditional_put)
  return conditional_put_;
}
inline ::proto::ConditionalPutRequest* InternalRaftCommandUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::proto::ConditionalPutRequest* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_conditional_put(::proto::ConditionalPutRequest* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.conditional_put)
}

// optional .proto.IncrementRequest increment = 5;
inline bool InternalRaftCommandUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalRaftCommandUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalRaftCommandUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalRaftCommandUnion::clear_increment() {
  if (increment_ != NULL) increment_->::proto::IncrementRequest::Clear();
  clear_has_increment();
}
inline const ::proto::IncrementRequest& InternalRaftCommandUnion::increment() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
inline ::proto::IncrementRequest* InternalRaftCommandUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) increment_ = new ::proto::IncrementRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.increment)
  return increment_;
}
inline ::proto::IncrementRequest* InternalRaftCommandUnion::release_increment() {
  clear_has_increment();
  ::proto::IncrementRequest* temp = increment_;
  increment_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_increment(::proto::IncrementRequest* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.increment)
}

// optional .proto.DeleteRequest delete = 6;
inline bool InternalRaftCommandUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InternalRaftCommandUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InternalRaftCommandUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InternalRaftCommandUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::proto::DeleteRequest::Clear();
  clear_has_delete_();
}
inline const ::proto::DeleteRequest& InternalRaftCommandUnion::delete_() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::proto::DeleteRequest* InternalRaftCommandUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) delete__ = new ::proto::DeleteRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.delete)
  return delete__;
}
inline ::proto::DeleteRequest* InternalRaftCommandUnion::release_delete_() {
  clear_has_delete_();
  ::proto::DeleteRequest* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_delete_(::proto::DeleteRequest* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.delete)
}

// optional .proto.DeleteRangeRequest delete_range = 7;
inline bool InternalRaftCommandUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InternalRaftCommandUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InternalRaftCommandUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InternalRaftCommandUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::proto::DeleteRangeRequest::Clear();
  clear_has_delete_range();
}
inline const ::proto::DeleteRangeRequest& InternalRaftCommandUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
inline ::proto::DeleteRangeRequest* InternalRaftCommandUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) delete_range_ = new ::proto::DeleteRangeRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.delete_range)
  return delete_range_;
}
inline ::proto::DeleteRangeRequest* InternalRaftCommandUnion::release_delete_range() {
  clear_has_delete_range();
  ::proto::DeleteRangeRequest* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_delete_range(::proto::DeleteRangeRequest* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.delete_range)
}

// optional .proto.ScanRequest scan = 8;
inline bool InternalRaftCommandUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InternalRaftCommandUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InternalRaftCommandUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InternalRaftCommandUnion::clear_scan() {
  if (scan_ != NULL) scan_->::proto::ScanRequest::Clear();
  clear_has_scan();
}
inline const ::proto::ScanRequest& InternalRaftCommandUnion::scan() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::proto::ScanRequest* InternalRaftCommandUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) scan_ = new ::proto::ScanRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.scan)
  return scan_;
}
inline ::proto::ScanRequest* InternalRaftCommandUnion::release_scan() {
  clear_has_scan();
  ::proto::ScanRequest* temp = scan_;
  scan_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_scan(::proto::ScanRequest* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.scan)
}

// optional .proto.EndTransactionRequest end_transaction = 9;
inline bool InternalRaftCommandUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InternalRaftCommandUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InternalRaftCommandUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InternalRaftCommandUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::proto::EndTransactionRequest::Clear();
  clear_has_end_transaction();
}
inline const ::proto::EndTransactionRequest& InternalRaftCommandUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
inline ::proto::EndTransactionRequest* InternalRaftCommandUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) end_transaction_ = new ::proto::EndTransactionRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.end_transaction)
  return end_transaction_;
}
inline ::proto::EndTransactionRequest* InternalRaftCommandUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::proto::EndTransactionRequest* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_end_transaction(::proto::EndTransactionRequest* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.end_transaction)
}

// optional .proto.ReapQueueRequest reap_queue = 10;
inline bool InternalRaftCommandUnion::has_reap_queue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InternalRaftCommandUnion::set_has_reap_queue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InternalRaftCommandUnion::clear_has_reap_queue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InternalRaftCommandUnion::clear_reap_queue() {
  if (reap_queue_ != NULL) reap_queue_->::proto::ReapQueueRequest::Clear();
  clear_has_reap_queue();
}
inline const ::proto::ReapQueueRequest& InternalRaftCommandUnion::reap_queue() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.reap_queue)
  return reap_queue_ != NULL ? *reap_queue_ : *default_instance_->reap_queue_;
}
inline ::proto::ReapQueueRequest* InternalRaftCommandUnion::mutable_reap_queue() {
  set_has_reap_queue();
  if (reap_queue_ == NULL) reap_queue_ = new ::proto::ReapQueueRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.reap_queue)
  return reap_queue_;
}
inline ::proto::ReapQueueRequest* InternalRaftCommandUnion::release_reap_queue() {
  clear_has_reap_queue();
  ::proto::ReapQueueRequest* temp = reap_queue_;
  reap_queue_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_reap_queue(::proto::ReapQueueRequest* reap_queue) {
  delete reap_queue_;
  reap_queue_ = reap_queue;
  if (reap_queue) {
    set_has_reap_queue();
  } else {
    clear_has_reap_queue();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.reap_queue)
}

// optional .proto.EnqueueUpdateRequest enqueue_update = 11;
inline bool InternalRaftCommandUnion::has_enqueue_update() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InternalRaftCommandUnion::set_has_enqueue_update() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InternalRaftCommandUnion::clear_has_enqueue_update() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InternalRaftCommandUnion::clear_enqueue_update() {
  if (enqueue_update_ != NULL) enqueue_update_->::proto::EnqueueUpdateRequest::Clear();
  clear_has_enqueue_update();
}
inline const ::proto::EnqueueUpdateRequest& InternalRaftCommandUnion::enqueue_update() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.enqueue_update)
  return enqueue_update_ != NULL ? *enqueue_update_ : *default_instance_->enqueue_update_;
}
inline ::proto::EnqueueUpdateRequest* InternalRaftCommandUnion::mutable_enqueue_update() {
  set_has_enqueue_update();
  if (enqueue_update_ == NULL) enqueue_update_ = new ::proto::EnqueueUpdateRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.enqueue_update)
  return enqueue_update_;
}
inline ::proto::EnqueueUpdateRequest* InternalRaftCommandUnion::release_enqueue_update() {
  clear_has_enqueue_update();
  ::proto::EnqueueUpdateRequest* temp = enqueue_update_;
  enqueue_update_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_enqueue_update(::proto::EnqueueUpdateRequest* enqueue_update) {
  delete enqueue_update_;
  enqueue_update_ = enqueue_update;
  if (enqueue_update) {
    set_has_enqueue_update();
  } else {
    clear_has_enqueue_update();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.enqueue_update)
}

// optional .proto.EnqueueMessageRequest enqueue_message = 12;
inline bool InternalRaftCommandUnion::has_enqueue_message() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InternalRaftCommandUnion::set_has_enqueue_message() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InternalRaftCommandUnion::clear_has_enqueue_message() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InternalRaftCommandUnion::clear_enqueue_message() {
  if (enqueue_message_ != NULL) enqueue_message_->::proto::EnqueueMessageRequest::Clear();
  clear_has_enqueue_message();
}
inline const ::proto::EnqueueMessageRequest& InternalRaftCommandUnion::enqueue_message() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.enqueue_message)
  return enqueue_message_ != NULL ? *enqueue_message_ : *default_instance_->enqueue_message_;
}
inline ::proto::EnqueueMessageRequest* InternalRaftCommandUnion::mutable_enqueue_message() {
  set_has_enqueue_message();
  if (enqueue_message_ == NULL) enqueue_message_ = new ::proto::EnqueueMessageRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.enqueue_message)
  return enqueue_message_;
}
inline ::proto::EnqueueMessageRequest* InternalRaftCommandUnion::release_enqueue_message() {
  clear_has_enqueue_message();
  ::proto::EnqueueMessageRequest* temp = enqueue_message_;
  enqueue_message_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_enqueue_message(::proto::EnqueueMessageRequest* enqueue_message) {
  delete enqueue_message_;
  enqueue_message_ = enqueue_message;
  if (enqueue_message) {
    set_has_enqueue_message();
  } else {
    clear_has_enqueue_message();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.enqueue_message)
}

// optional .proto.BatchRequest batch = 30;
inline bool InternalRaftCommandUnion::has_batch() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_batch() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InternalRaftCommandUnion::clear_has_batch() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InternalRaftCommandUnion::clear_batch() {
  if (batch_ != NULL) batch_->::proto::BatchRequest::Clear();
  clear_has_batch();
}
inline const ::proto::BatchRequest& InternalRaftCommandUnion::batch() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.batch)
  return batch_ != NULL ? *batch_ : *default_instance_->batch_;
}
inline ::proto::BatchRequest* InternalRaftCommandUnion::mutable_batch() {
  set_has_batch();
  if (batch_ == NULL) batch_ = new ::proto::BatchRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.batch)
  return batch_;
}
inline ::proto::BatchRequest* InternalRaftCommandUnion::release_batch() {
  clear_has_batch();
  ::proto::BatchRequest* temp = batch_;
  batch_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_batch(::proto::BatchRequest* batch) {
  delete batch_;
  batch_ = batch;
  if (batch) {
    set_has_batch();
  } else {
    clear_has_batch();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.batch)
}

// optional .proto.InternalRangeLookupRequest internal_range_lookup = 31;
inline bool InternalRaftCommandUnion::has_internal_range_lookup() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_internal_range_lookup() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InternalRaftCommandUnion::clear_has_internal_range_lookup() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InternalRaftCommandUnion::clear_internal_range_lookup() {
  if (internal_range_lookup_ != NULL) internal_range_lookup_->::proto::InternalRangeLookupRequest::Clear();
  clear_has_internal_range_lookup();
}
inline const ::proto::InternalRangeLookupRequest& InternalRaftCommandUnion::internal_range_lookup() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.internal_range_lookup)
  return internal_range_lookup_ != NULL ? *internal_range_lookup_ : *default_instance_->internal_range_lookup_;
}
inline ::proto::InternalRangeLookupRequest* InternalRaftCommandUnion::mutable_internal_range_lookup() {
  set_has_internal_range_lookup();
  if (internal_range_lookup_ == NULL) internal_range_lookup_ = new ::proto::InternalRangeLookupRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.internal_range_lookup)
  return internal_range_lookup_;
}
inline ::proto::InternalRangeLookupRequest* InternalRaftCommandUnion::release_internal_range_lookup() {
  clear_has_internal_range_lookup();
  ::proto::InternalRangeLookupRequest* temp = internal_range_lookup_;
  internal_range_lookup_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_internal_range_lookup(::proto::InternalRangeLookupRequest* internal_range_lookup) {
  delete internal_range_lookup_;
  internal_range_lookup_ = internal_range_lookup;
  if (internal_range_lookup) {
    set_has_internal_range_lookup();
  } else {
    clear_has_internal_range_lookup();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.internal_range_lookup)
}

// optional .proto.InternalHeartbeatTxnRequest internal_heartbeat_txn = 32;
inline bool InternalRaftCommandUnion::has_internal_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_internal_heartbeat_txn() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InternalRaftCommandUnion::clear_has_internal_heartbeat_txn() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InternalRaftCommandUnion::clear_internal_heartbeat_txn() {
  if (internal_heartbeat_txn_ != NULL) internal_heartbeat_txn_->::proto::InternalHeartbeatTxnRequest::Clear();
  clear_has_internal_heartbeat_txn();
}
inline const ::proto::InternalHeartbeatTxnRequest& InternalRaftCommandUnion::internal_heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.internal_heartbeat_txn)
  return internal_heartbeat_txn_ != NULL ? *internal_heartbeat_txn_ : *default_instance_->internal_heartbeat_txn_;
}
inline ::proto::InternalHeartbeatTxnRequest* InternalRaftCommandUnion::mutable_internal_heartbeat_txn() {
  set_has_internal_heartbeat_txn();
  if (internal_heartbeat_txn_ == NULL) internal_heartbeat_txn_ = new ::proto::InternalHeartbeatTxnRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.internal_heartbeat_txn)
  return internal_heartbeat_txn_;
}
inline ::proto::InternalHeartbeatTxnRequest* InternalRaftCommandUnion::release_internal_heartbeat_txn() {
  clear_has_internal_heartbeat_txn();
  ::proto::InternalHeartbeatTxnRequest* temp = internal_heartbeat_txn_;
  internal_heartbeat_txn_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_internal_heartbeat_txn(::proto::InternalHeartbeatTxnRequest* internal_heartbeat_txn) {
  delete internal_heartbeat_txn_;
  internal_heartbeat_txn_ = internal_heartbeat_txn;
  if (internal_heartbeat_txn) {
    set_has_internal_heartbeat_txn();
  } else {
    clear_has_internal_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.internal_heartbeat_txn)
}

// optional .proto.InternalPushTxnRequest internal_push_txn = 33;
inline bool InternalRaftCommandUnion::has_internal_push_txn() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_internal_push_txn() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InternalRaftCommandUnion::clear_has_internal_push_txn() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InternalRaftCommandUnion::clear_internal_push_txn() {
  if (internal_push_txn_ != NULL) internal_push_txn_->::proto::InternalPushTxnRequest::Clear();
  clear_has_internal_push_txn();
}
inline const ::proto::InternalPushTxnRequest& InternalRaftCommandUnion::internal_push_txn() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.internal_push_txn)
  return internal_push_txn_ != NULL ? *internal_push_txn_ : *default_instance_->internal_push_txn_;
}
inline ::proto::InternalPushTxnRequest* InternalRaftCommandUnion::mutable_internal_push_txn() {
  set_has_internal_push_txn();
  if (internal_push_txn_ == NULL) internal_push_txn_ = new ::proto::InternalPushTxnRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.internal_push_txn)
  return internal_push_txn_;
}
inline ::proto::InternalPushTxnRequest* InternalRaftCommandUnion::release_internal_push_txn() {
  clear_has_internal_push_txn();
  ::proto::InternalPushTxnRequest* temp = internal_push_txn_;
  internal_push_txn_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_internal_push_txn(::proto::InternalPushTxnRequest* internal_push_txn) {
  delete internal_push_txn_;
  internal_push_txn_ = internal_push_txn;
  if (internal_push_txn) {
    set_has_internal_push_txn();
  } else {
    clear_has_internal_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.internal_push_txn)
}

// optional .proto.InternalResolveIntentRequest internal_resolve_intent = 34;
inline bool InternalRaftCommandUnion::has_internal_resolve_intent() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_internal_resolve_intent() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InternalRaftCommandUnion::clear_has_internal_resolve_intent() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InternalRaftCommandUnion::clear_internal_resolve_intent() {
  if (internal_resolve_intent_ != NULL) internal_resolve_intent_->::proto::InternalResolveIntentRequest::Clear();
  clear_has_internal_resolve_intent();
}
inline const ::proto::InternalResolveIntentRequest& InternalRaftCommandUnion::internal_resolve_intent() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.internal_resolve_intent)
  return internal_resolve_intent_ != NULL ? *internal_resolve_intent_ : *default_instance_->internal_resolve_intent_;
}
inline ::proto::InternalResolveIntentRequest* InternalRaftCommandUnion::mutable_internal_resolve_intent() {
  set_has_internal_resolve_intent();
  if (internal_resolve_intent_ == NULL) internal_resolve_intent_ = new ::proto::InternalResolveIntentRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.internal_resolve_intent)
  return internal_resolve_intent_;
}
inline ::proto::InternalResolveIntentRequest* InternalRaftCommandUnion::release_internal_resolve_intent() {
  clear_has_internal_resolve_intent();
  ::proto::InternalResolveIntentRequest* temp = internal_resolve_intent_;
  internal_resolve_intent_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_internal_resolve_intent(::proto::InternalResolveIntentRequest* internal_resolve_intent) {
  delete internal_resolve_intent_;
  internal_resolve_intent_ = internal_resolve_intent;
  if (internal_resolve_intent) {
    set_has_internal_resolve_intent();
  } else {
    clear_has_internal_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.internal_resolve_intent)
}

// optional .proto.InternalMergeRequest internal_merge_response = 35;
inline bool InternalRaftCommandUnion::has_internal_merge_response() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_internal_merge_response() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InternalRaftCommandUnion::clear_has_internal_merge_response() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InternalRaftCommandUnion::clear_internal_merge_response() {
  if (internal_merge_response_ != NULL) internal_merge_response_->::proto::InternalMergeRequest::Clear();
  clear_has_internal_merge_response();
}
inline const ::proto::InternalMergeRequest& InternalRaftCommandUnion::internal_merge_response() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.internal_merge_response)
  return internal_merge_response_ != NULL ? *internal_merge_response_ : *default_instance_->internal_merge_response_;
}
inline ::proto::InternalMergeRequest* InternalRaftCommandUnion::mutable_internal_merge_response() {
  set_has_internal_merge_response();
  if (internal_merge_response_ == NULL) internal_merge_response_ = new ::proto::InternalMergeRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.internal_merge_response)
  return internal_merge_response_;
}
inline ::proto::InternalMergeRequest* InternalRaftCommandUnion::release_internal_merge_response() {
  clear_has_internal_merge_response();
  ::proto::InternalMergeRequest* temp = internal_merge_response_;
  internal_merge_response_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_internal_merge_response(::proto::InternalMergeRequest* internal_merge_response) {
  delete internal_merge_response_;
  internal_merge_response_ = internal_merge_response;
  if (internal_merge_response) {
    set_has_internal_merge_response();
  } else {
    clear_has_internal_merge_response();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.internal_merge_response)
}

// optional .proto.InternalTruncateLogRequest internal_truncate_log = 36;
inline bool InternalRaftCommandUnion::has_internal_truncate_log() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_internal_truncate_log() {
  _has_bits_[0] |= 0x00040000u;
}
inline void InternalRaftCommandUnion::clear_has_internal_truncate_log() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void InternalRaftCommandUnion::clear_internal_truncate_log() {
  if (internal_truncate_log_ != NULL) internal_truncate_log_->::proto::InternalTruncateLogRequest::Clear();
  clear_has_internal_truncate_log();
}
inline const ::proto::InternalTruncateLogRequest& InternalRaftCommandUnion::internal_truncate_log() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.internal_truncate_log)
  return internal_truncate_log_ != NULL ? *internal_truncate_log_ : *default_instance_->internal_truncate_log_;
}
inline ::proto::InternalTruncateLogRequest* InternalRaftCommandUnion::mutable_internal_truncate_log() {
  set_has_internal_truncate_log();
  if (internal_truncate_log_ == NULL) internal_truncate_log_ = new ::proto::InternalTruncateLogRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.internal_truncate_log)
  return internal_truncate_log_;
}
inline ::proto::InternalTruncateLogRequest* InternalRaftCommandUnion::release_internal_truncate_log() {
  clear_has_internal_truncate_log();
  ::proto::InternalTruncateLogRequest* temp = internal_truncate_log_;
  internal_truncate_log_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_internal_truncate_log(::proto::InternalTruncateLogRequest* internal_truncate_log) {
  delete internal_truncate_log_;
  internal_truncate_log_ = internal_truncate_log;
  if (internal_truncate_log) {
    set_has_internal_truncate_log();
  } else {
    clear_has_internal_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.internal_truncate_log)
}

// optional .proto.InternalGCRequest internal_gc = 37;
inline bool InternalRaftCommandUnion::has_internal_gc() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void InternalRaftCommandUnion::set_has_internal_gc() {
  _has_bits_[0] |= 0x00080000u;
}
inline void InternalRaftCommandUnion::clear_has_internal_gc() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void InternalRaftCommandUnion::clear_internal_gc() {
  if (internal_gc_ != NULL) internal_gc_->::proto::InternalGCRequest::Clear();
  clear_has_internal_gc();
}
inline const ::proto::InternalGCRequest& InternalRaftCommandUnion::internal_gc() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommandUnion.internal_gc)
  return internal_gc_ != NULL ? *internal_gc_ : *default_instance_->internal_gc_;
}
inline ::proto::InternalGCRequest* InternalRaftCommandUnion::mutable_internal_gc() {
  set_has_internal_gc();
  if (internal_gc_ == NULL) internal_gc_ = new ::proto::InternalGCRequest;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommandUnion.internal_gc)
  return internal_gc_;
}
inline ::proto::InternalGCRequest* InternalRaftCommandUnion::release_internal_gc() {
  clear_has_internal_gc();
  ::proto::InternalGCRequest* temp = internal_gc_;
  internal_gc_ = NULL;
  return temp;
}
inline void InternalRaftCommandUnion::set_allocated_internal_gc(::proto::InternalGCRequest* internal_gc) {
  delete internal_gc_;
  internal_gc_ = internal_gc;
  if (internal_gc) {
    set_has_internal_gc();
  } else {
    clear_has_internal_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommandUnion.internal_gc)
}

// -------------------------------------------------------------------

// InternalRaftCommand

// optional int64 raft_id = 2;
inline bool InternalRaftCommand::has_raft_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRaftCommand::set_has_raft_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRaftCommand::clear_has_raft_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRaftCommand::clear_raft_id() {
  raft_id_ = GOOGLE_LONGLONG(0);
  clear_has_raft_id();
}
inline ::google::protobuf::int64 InternalRaftCommand::raft_id() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommand.raft_id)
  return raft_id_;
}
inline void InternalRaftCommand::set_raft_id(::google::protobuf::int64 value) {
  set_has_raft_id();
  raft_id_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalRaftCommand.raft_id)
}

// optional .proto.InternalRaftCommandUnion cmd = 3;
inline bool InternalRaftCommand::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalRaftCommand::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalRaftCommand::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalRaftCommand::clear_cmd() {
  if (cmd_ != NULL) cmd_->::proto::InternalRaftCommandUnion::Clear();
  clear_has_cmd();
}
inline const ::proto::InternalRaftCommandUnion& InternalRaftCommand::cmd() const {
  // @@protoc_insertion_point(field_get:proto.InternalRaftCommand.cmd)
  return cmd_ != NULL ? *cmd_ : *default_instance_->cmd_;
}
inline ::proto::InternalRaftCommandUnion* InternalRaftCommand::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == NULL) cmd_ = new ::proto::InternalRaftCommandUnion;
  // @@protoc_insertion_point(field_mutable:proto.InternalRaftCommand.cmd)
  return cmd_;
}
inline ::proto::InternalRaftCommandUnion* InternalRaftCommand::release_cmd() {
  clear_has_cmd();
  ::proto::InternalRaftCommandUnion* temp = cmd_;
  cmd_ = NULL;
  return temp;
}
inline void InternalRaftCommand::set_allocated_cmd(::proto::InternalRaftCommandUnion* cmd) {
  delete cmd_;
  cmd_ = cmd;
  if (cmd) {
    set_has_cmd();
  } else {
    clear_has_cmd();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.InternalRaftCommand.cmd)
}

// -------------------------------------------------------------------

// InternalTimeSeriesData

// optional int64 start_timestamp_nanos = 1;
inline bool InternalTimeSeriesData::has_start_timestamp_nanos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTimeSeriesData::set_has_start_timestamp_nanos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTimeSeriesData::clear_has_start_timestamp_nanos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTimeSeriesData::clear_start_timestamp_nanos() {
  start_timestamp_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_start_timestamp_nanos();
}
inline ::google::protobuf::int64 InternalTimeSeriesData::start_timestamp_nanos() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesData.start_timestamp_nanos)
  return start_timestamp_nanos_;
}
inline void InternalTimeSeriesData::set_start_timestamp_nanos(::google::protobuf::int64 value) {
  set_has_start_timestamp_nanos();
  start_timestamp_nanos_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesData.start_timestamp_nanos)
}

// optional int64 sample_duration_nanos = 2;
inline bool InternalTimeSeriesData::has_sample_duration_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTimeSeriesData::set_has_sample_duration_nanos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTimeSeriesData::clear_has_sample_duration_nanos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTimeSeriesData::clear_sample_duration_nanos() {
  sample_duration_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_sample_duration_nanos();
}
inline ::google::protobuf::int64 InternalTimeSeriesData::sample_duration_nanos() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesData.sample_duration_nanos)
  return sample_duration_nanos_;
}
inline void InternalTimeSeriesData::set_sample_duration_nanos(::google::protobuf::int64 value) {
  set_has_sample_duration_nanos();
  sample_duration_nanos_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesData.sample_duration_nanos)
}

// repeated .proto.InternalTimeSeriesSample samples = 3;
inline int InternalTimeSeriesData::samples_size() const {
  return samples_.size();
}
inline void InternalTimeSeriesData::clear_samples() {
  samples_.Clear();
}
inline const ::proto::InternalTimeSeriesSample& InternalTimeSeriesData::samples(int index) const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesData.samples)
  return samples_.Get(index);
}
inline ::proto::InternalTimeSeriesSample* InternalTimeSeriesData::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:proto.InternalTimeSeriesData.samples)
  return samples_.Mutable(index);
}
inline ::proto::InternalTimeSeriesSample* InternalTimeSeriesData::add_samples() {
  // @@protoc_insertion_point(field_add:proto.InternalTimeSeriesData.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::InternalTimeSeriesSample >&
InternalTimeSeriesData::samples() const {
  // @@protoc_insertion_point(field_list:proto.InternalTimeSeriesData.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::InternalTimeSeriesSample >*
InternalTimeSeriesData::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:proto.InternalTimeSeriesData.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InternalTimeSeriesSample

// optional int32 offset = 1;
inline bool InternalTimeSeriesSample::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTimeSeriesSample::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTimeSeriesSample::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTimeSeriesSample::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 InternalTimeSeriesSample::offset() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.offset)
  return offset_;
}
inline void InternalTimeSeriesSample::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.offset)
}

// optional uint32 int_count = 2;
inline bool InternalTimeSeriesSample::has_int_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTimeSeriesSample::set_has_int_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTimeSeriesSample::clear_has_int_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTimeSeriesSample::clear_int_count() {
  int_count_ = 0u;
  clear_has_int_count();
}
inline ::google::protobuf::uint32 InternalTimeSeriesSample::int_count() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.int_count)
  return int_count_;
}
inline void InternalTimeSeriesSample::set_int_count(::google::protobuf::uint32 value) {
  set_has_int_count();
  int_count_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.int_count)
}

// optional int64 int_sum = 3;
inline bool InternalTimeSeriesSample::has_int_sum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalTimeSeriesSample::set_has_int_sum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalTimeSeriesSample::clear_has_int_sum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalTimeSeriesSample::clear_int_sum() {
  int_sum_ = GOOGLE_LONGLONG(0);
  clear_has_int_sum();
}
inline ::google::protobuf::int64 InternalTimeSeriesSample::int_sum() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.int_sum)
  return int_sum_;
}
inline void InternalTimeSeriesSample::set_int_sum(::google::protobuf::int64 value) {
  set_has_int_sum();
  int_sum_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.int_sum)
}

// optional int64 int_max = 4;
inline bool InternalTimeSeriesSample::has_int_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalTimeSeriesSample::set_has_int_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalTimeSeriesSample::clear_has_int_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalTimeSeriesSample::clear_int_max() {
  int_max_ = GOOGLE_LONGLONG(0);
  clear_has_int_max();
}
inline ::google::protobuf::int64 InternalTimeSeriesSample::int_max() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.int_max)
  return int_max_;
}
inline void InternalTimeSeriesSample::set_int_max(::google::protobuf::int64 value) {
  set_has_int_max();
  int_max_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.int_max)
}

// optional int64 int_min = 5;
inline bool InternalTimeSeriesSample::has_int_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalTimeSeriesSample::set_has_int_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalTimeSeriesSample::clear_has_int_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalTimeSeriesSample::clear_int_min() {
  int_min_ = GOOGLE_LONGLONG(0);
  clear_has_int_min();
}
inline ::google::protobuf::int64 InternalTimeSeriesSample::int_min() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.int_min)
  return int_min_;
}
inline void InternalTimeSeriesSample::set_int_min(::google::protobuf::int64 value) {
  set_has_int_min();
  int_min_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.int_min)
}

// optional uint32 float_count = 6;
inline bool InternalTimeSeriesSample::has_float_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InternalTimeSeriesSample::set_has_float_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InternalTimeSeriesSample::clear_has_float_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InternalTimeSeriesSample::clear_float_count() {
  float_count_ = 0u;
  clear_has_float_count();
}
inline ::google::protobuf::uint32 InternalTimeSeriesSample::float_count() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.float_count)
  return float_count_;
}
inline void InternalTimeSeriesSample::set_float_count(::google::protobuf::uint32 value) {
  set_has_float_count();
  float_count_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.float_count)
}

// optional float float_sum = 7;
inline bool InternalTimeSeriesSample::has_float_sum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InternalTimeSeriesSample::set_has_float_sum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InternalTimeSeriesSample::clear_has_float_sum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InternalTimeSeriesSample::clear_float_sum() {
  float_sum_ = 0;
  clear_has_float_sum();
}
inline float InternalTimeSeriesSample::float_sum() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.float_sum)
  return float_sum_;
}
inline void InternalTimeSeriesSample::set_float_sum(float value) {
  set_has_float_sum();
  float_sum_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.float_sum)
}

// optional float float_max = 8;
inline bool InternalTimeSeriesSample::has_float_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InternalTimeSeriesSample::set_has_float_max() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InternalTimeSeriesSample::clear_has_float_max() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InternalTimeSeriesSample::clear_float_max() {
  float_max_ = 0;
  clear_has_float_max();
}
inline float InternalTimeSeriesSample::float_max() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.float_max)
  return float_max_;
}
inline void InternalTimeSeriesSample::set_float_max(float value) {
  set_has_float_max();
  float_max_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.float_max)
}

// optional float float_min = 9;
inline bool InternalTimeSeriesSample::has_float_min() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InternalTimeSeriesSample::set_has_float_min() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InternalTimeSeriesSample::clear_has_float_min() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InternalTimeSeriesSample::clear_float_min() {
  float_min_ = 0;
  clear_has_float_min();
}
inline float InternalTimeSeriesSample::float_min() const {
  // @@protoc_insertion_point(field_get:proto.InternalTimeSeriesSample.float_min)
  return float_min_;
}
inline void InternalTimeSeriesSample::set_float_min(float value) {
  set_has_float_min();
  float_min_ = value;
  // @@protoc_insertion_point(field_set:proto.InternalTimeSeriesSample.float_min)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::InternalValueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::InternalValueType>() {
  return ::proto::InternalValueType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_internal_2eproto__INCLUDED
