// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

#ifndef PROTOBUF_api_2eproto__INCLUDED
#define PROTOBUF_api_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "config.pb.h"
#include "data.pb.h"
#include "errors.pb.h"
#include "github.com/gogo/protobuf/gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_api_2eproto();
void protobuf_AssignDesc_api_2eproto();
void protobuf_ShutdownFile_api_2eproto();

class ClientCmdID;
class RequestHeader;
class ResponseHeader;
class ContainsRequest;
class ContainsResponse;
class GetRequest;
class GetResponse;
class PutRequest;
class PutResponse;
class ConditionalPutRequest;
class ConditionalPutResponse;
class IncrementRequest;
class IncrementResponse;
class DeleteRequest;
class DeleteResponse;
class DeleteRangeRequest;
class DeleteRangeResponse;
class ScanRequest;
class ScanResponse;
class EndTransactionRequest;
class EndTransactionResponse;
class ReapQueueRequest;
class ReapQueueResponse;
class EnqueueUpdateRequest;
class EnqueueUpdateResponse;
class EnqueueMessageRequest;
class EnqueueMessageResponse;
class RequestUnion;
class ResponseUnion;
class BatchRequest;
class BatchResponse;
class AdminSplitRequest;
class AdminSplitResponse;
class AdminMergeRequest;
class AdminMergeResponse;

// ===================================================================

class ClientCmdID : public ::google::protobuf::Message {
 public:
  ClientCmdID();
  virtual ~ClientCmdID();

  ClientCmdID(const ClientCmdID& from);

  inline ClientCmdID& operator=(const ClientCmdID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCmdID& default_instance();

  void Swap(ClientCmdID* other);

  // implements Message ----------------------------------------------

  ClientCmdID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCmdID& from);
  void MergeFrom(const ClientCmdID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 wall_time = 1;
  inline bool has_wall_time() const;
  inline void clear_wall_time();
  static const int kWallTimeFieldNumber = 1;
  inline ::google::protobuf::int64 wall_time() const;
  inline void set_wall_time(::google::protobuf::int64 value);

  // optional int64 random = 2;
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 2;
  inline ::google::protobuf::int64 random() const;
  inline void set_random(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.ClientCmdID)
 private:
  inline void set_has_wall_time();
  inline void clear_has_wall_time();
  inline void set_has_random();
  inline void clear_has_random();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 wall_time_;
  ::google::protobuf::int64 random_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ClientCmdID* default_instance_;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  void Swap(RequestHeader* other);

  // implements Message ----------------------------------------------

  RequestHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.Timestamp timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::proto::Timestamp& timestamp() const;
  inline ::proto::Timestamp* mutable_timestamp();
  inline ::proto::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::proto::Timestamp* timestamp);

  // optional .proto.ClientCmdID cmd_id = 2;
  inline bool has_cmd_id() const;
  inline void clear_cmd_id();
  static const int kCmdIdFieldNumber = 2;
  inline const ::proto::ClientCmdID& cmd_id() const;
  inline ::proto::ClientCmdID* mutable_cmd_id();
  inline ::proto::ClientCmdID* release_cmd_id();
  inline void set_allocated_cmd_id(::proto::ClientCmdID* cmd_id);

  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes end_key = 4;
  inline bool has_end_key() const;
  inline void clear_end_key();
  static const int kEndKeyFieldNumber = 4;
  inline const ::std::string& end_key() const;
  inline void set_end_key(const ::std::string& value);
  inline void set_end_key(const char* value);
  inline void set_end_key(const void* value, size_t size);
  inline ::std::string* mutable_end_key();
  inline ::std::string* release_end_key();
  inline void set_allocated_end_key(::std::string* end_key);

  // optional string user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional .proto.Replica replica = 6;
  inline bool has_replica() const;
  inline void clear_replica();
  static const int kReplicaFieldNumber = 6;
  inline const ::proto::Replica& replica() const;
  inline ::proto::Replica* mutable_replica();
  inline ::proto::Replica* release_replica();
  inline void set_allocated_replica(::proto::Replica* replica);

  // optional int64 raft_id = 7;
  inline bool has_raft_id() const;
  inline void clear_raft_id();
  static const int kRaftIdFieldNumber = 7;
  inline ::google::protobuf::int64 raft_id() const;
  inline void set_raft_id(::google::protobuf::int64 value);

  // optional int32 user_priority = 8 [default = 1];
  inline bool has_user_priority() const;
  inline void clear_user_priority();
  static const int kUserPriorityFieldNumber = 8;
  inline ::google::protobuf::int32 user_priority() const;
  inline void set_user_priority(::google::protobuf::int32 value);

  // optional .proto.Transaction txn = 9;
  inline bool has_txn() const;
  inline void clear_txn();
  static const int kTxnFieldNumber = 9;
  inline const ::proto::Transaction& txn() const;
  inline ::proto::Transaction* mutable_txn();
  inline ::proto::Transaction* release_txn();
  inline void set_allocated_txn(::proto::Transaction* txn);

  // @@protoc_insertion_point(class_scope:proto.RequestHeader)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_cmd_id();
  inline void clear_has_cmd_id();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_end_key();
  inline void clear_has_end_key();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_replica();
  inline void clear_has_replica();
  inline void set_has_raft_id();
  inline void clear_has_raft_id();
  inline void set_has_user_priority();
  inline void clear_has_user_priority();
  inline void set_has_txn();
  inline void clear_has_txn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::Timestamp* timestamp_;
  ::proto::ClientCmdID* cmd_id_;
  ::std::string* key_;
  ::std::string* end_key_;
  ::std::string* user_;
  ::proto::Replica* replica_;
  ::google::protobuf::int64 raft_id_;
  ::proto::Transaction* txn_;
  ::google::protobuf::int32 user_priority_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static RequestHeader* default_instance_;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  void Swap(ResponseHeader* other);

  // implements Message ----------------------------------------------

  ResponseHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::proto::Error& error() const;
  inline ::proto::Error* mutable_error();
  inline ::proto::Error* release_error();
  inline void set_allocated_error(::proto::Error* error);

  // optional .proto.Timestamp timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::proto::Timestamp& timestamp() const;
  inline ::proto::Timestamp* mutable_timestamp();
  inline ::proto::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::proto::Timestamp* timestamp);

  // optional .proto.Transaction txn = 3;
  inline bool has_txn() const;
  inline void clear_txn();
  static const int kTxnFieldNumber = 3;
  inline const ::proto::Transaction& txn() const;
  inline ::proto::Transaction* mutable_txn();
  inline ::proto::Transaction* release_txn();
  inline void set_allocated_txn(::proto::Transaction* txn);

  // @@protoc_insertion_point(class_scope:proto.ResponseHeader)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_txn();
  inline void clear_has_txn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::Error* error_;
  ::proto::Timestamp* timestamp_;
  ::proto::Transaction* txn_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ResponseHeader* default_instance_;
};
// -------------------------------------------------------------------

class ContainsRequest : public ::google::protobuf::Message {
 public:
  ContainsRequest();
  virtual ~ContainsRequest();

  ContainsRequest(const ContainsRequest& from);

  inline ContainsRequest& operator=(const ContainsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainsRequest& default_instance();

  void Swap(ContainsRequest* other);

  // implements Message ----------------------------------------------

  ContainsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainsRequest& from);
  void MergeFrom(const ContainsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:proto.ContainsRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ContainsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ContainsResponse : public ::google::protobuf::Message {
 public:
  ContainsResponse();
  virtual ~ContainsResponse();

  ContainsResponse(const ContainsResponse& from);

  inline ContainsResponse& operator=(const ContainsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainsResponse& default_instance();

  void Swap(ContainsResponse* other);

  // implements Message ----------------------------------------------

  ContainsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainsResponse& from);
  void MergeFrom(const ContainsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // optional bool exists = 2;
  inline bool has_exists() const;
  inline void clear_exists();
  static const int kExistsFieldNumber = 2;
  inline bool exists() const;
  inline void set_exists(bool value);

  // @@protoc_insertion_point(class_scope:proto.ContainsResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_exists();
  inline void clear_has_exists();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  bool exists_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ContainsResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();

  void Swap(GetRequest* other);

  // implements Message ----------------------------------------------

  GetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:proto.GetRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static GetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();

  void Swap(GetResponse* other);

  // implements Message ----------------------------------------------

  GetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // optional .proto.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::proto::Value& value() const;
  inline ::proto::Value* mutable_value();
  inline ::proto::Value* release_value();
  inline void set_allocated_value(::proto::Value* value);

  // @@protoc_insertion_point(class_scope:proto.GetResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::proto::Value* value_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static GetResponse* default_instance_;
};
// -------------------------------------------------------------------

class PutRequest : public ::google::protobuf::Message {
 public:
  PutRequest();
  virtual ~PutRequest();

  PutRequest(const PutRequest& from);

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PutRequest& default_instance();

  void Swap(PutRequest* other);

  // implements Message ----------------------------------------------

  PutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional .proto.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::proto::Value& value() const;
  inline ::proto::Value* mutable_value();
  inline ::proto::Value* release_value();
  inline void set_allocated_value(::proto::Value* value);

  // @@protoc_insertion_point(class_scope:proto.PutRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::Value* value_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static PutRequest* default_instance_;
};
// -------------------------------------------------------------------

class PutResponse : public ::google::protobuf::Message {
 public:
  PutResponse();
  virtual ~PutResponse();

  PutResponse(const PutResponse& from);

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PutResponse& default_instance();

  void Swap(PutResponse* other);

  // implements Message ----------------------------------------------

  PutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutResponse& from);
  void MergeFrom(const PutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.PutResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static PutResponse* default_instance_;
};
// -------------------------------------------------------------------

class ConditionalPutRequest : public ::google::protobuf::Message {
 public:
  ConditionalPutRequest();
  virtual ~ConditionalPutRequest();

  ConditionalPutRequest(const ConditionalPutRequest& from);

  inline ConditionalPutRequest& operator=(const ConditionalPutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionalPutRequest& default_instance();

  void Swap(ConditionalPutRequest* other);

  // implements Message ----------------------------------------------

  ConditionalPutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionalPutRequest& from);
  void MergeFrom(const ConditionalPutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional .proto.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::proto::Value& value() const;
  inline ::proto::Value* mutable_value();
  inline ::proto::Value* release_value();
  inline void set_allocated_value(::proto::Value* value);

  // optional .proto.Value exp_value = 3;
  inline bool has_exp_value() const;
  inline void clear_exp_value();
  static const int kExpValueFieldNumber = 3;
  inline const ::proto::Value& exp_value() const;
  inline ::proto::Value* mutable_exp_value();
  inline ::proto::Value* release_exp_value();
  inline void set_allocated_exp_value(::proto::Value* exp_value);

  // @@protoc_insertion_point(class_scope:proto.ConditionalPutRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_exp_value();
  inline void clear_has_exp_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::Value* value_;
  ::proto::Value* exp_value_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ConditionalPutRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConditionalPutResponse : public ::google::protobuf::Message {
 public:
  ConditionalPutResponse();
  virtual ~ConditionalPutResponse();

  ConditionalPutResponse(const ConditionalPutResponse& from);

  inline ConditionalPutResponse& operator=(const ConditionalPutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionalPutResponse& default_instance();

  void Swap(ConditionalPutResponse* other);

  // implements Message ----------------------------------------------

  ConditionalPutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionalPutResponse& from);
  void MergeFrom(const ConditionalPutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.ConditionalPutResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ConditionalPutResponse* default_instance_;
};
// -------------------------------------------------------------------

class IncrementRequest : public ::google::protobuf::Message {
 public:
  IncrementRequest();
  virtual ~IncrementRequest();

  IncrementRequest(const IncrementRequest& from);

  inline IncrementRequest& operator=(const IncrementRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncrementRequest& default_instance();

  void Swap(IncrementRequest* other);

  // implements Message ----------------------------------------------

  IncrementRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncrementRequest& from);
  void MergeFrom(const IncrementRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional int64 increment = 2;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 2;
  inline ::google::protobuf::int64 increment() const;
  inline void set_increment(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.IncrementRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_increment();
  inline void clear_has_increment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::google::protobuf::int64 increment_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static IncrementRequest* default_instance_;
};
// -------------------------------------------------------------------

class IncrementResponse : public ::google::protobuf::Message {
 public:
  IncrementResponse();
  virtual ~IncrementResponse();

  IncrementResponse(const IncrementResponse& from);

  inline IncrementResponse& operator=(const IncrementResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncrementResponse& default_instance();

  void Swap(IncrementResponse* other);

  // implements Message ----------------------------------------------

  IncrementResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncrementResponse& from);
  void MergeFrom(const IncrementResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // optional int64 new_value = 2;
  inline bool has_new_value() const;
  inline void clear_new_value();
  static const int kNewValueFieldNumber = 2;
  inline ::google::protobuf::int64 new_value() const;
  inline void set_new_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.IncrementResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_new_value();
  inline void clear_has_new_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::google::protobuf::int64 new_value_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static IncrementResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  void Swap(DeleteRequest* other);

  // implements Message ----------------------------------------------

  DeleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:proto.DeleteRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static DeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();

  void Swap(DeleteResponse* other);

  // implements Message ----------------------------------------------

  DeleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.DeleteResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static DeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRangeRequest : public ::google::protobuf::Message {
 public:
  DeleteRangeRequest();
  virtual ~DeleteRangeRequest();

  DeleteRangeRequest(const DeleteRangeRequest& from);

  inline DeleteRangeRequest& operator=(const DeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeRequest& default_instance();

  void Swap(DeleteRangeRequest* other);

  // implements Message ----------------------------------------------

  DeleteRangeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRangeRequest& from);
  void MergeFrom(const DeleteRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional int64 max_entries_to_delete = 2;
  inline bool has_max_entries_to_delete() const;
  inline void clear_max_entries_to_delete();
  static const int kMaxEntriesToDeleteFieldNumber = 2;
  inline ::google::protobuf::int64 max_entries_to_delete() const;
  inline void set_max_entries_to_delete(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.DeleteRangeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_entries_to_delete();
  inline void clear_has_max_entries_to_delete();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::google::protobuf::int64 max_entries_to_delete_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static DeleteRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRangeResponse : public ::google::protobuf::Message {
 public:
  DeleteRangeResponse();
  virtual ~DeleteRangeResponse();

  DeleteRangeResponse(const DeleteRangeResponse& from);

  inline DeleteRangeResponse& operator=(const DeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeResponse& default_instance();

  void Swap(DeleteRangeResponse* other);

  // implements Message ----------------------------------------------

  DeleteRangeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRangeResponse& from);
  void MergeFrom(const DeleteRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // optional int64 num_deleted = 2;
  inline bool has_num_deleted() const;
  inline void clear_num_deleted();
  static const int kNumDeletedFieldNumber = 2;
  inline ::google::protobuf::int64 num_deleted() const;
  inline void set_num_deleted(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.DeleteRangeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_num_deleted();
  inline void clear_has_num_deleted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::google::protobuf::int64 num_deleted_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static DeleteRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class ScanRequest : public ::google::protobuf::Message {
 public:
  ScanRequest();
  virtual ~ScanRequest();

  ScanRequest(const ScanRequest& from);

  inline ScanRequest& operator=(const ScanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanRequest& default_instance();

  void Swap(ScanRequest* other);

  // implements Message ----------------------------------------------

  ScanRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanRequest& from);
  void MergeFrom(const ScanRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional int64 max_results = 2;
  inline bool has_max_results() const;
  inline void clear_max_results();
  static const int kMaxResultsFieldNumber = 2;
  inline ::google::protobuf::int64 max_results() const;
  inline void set_max_results(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.ScanRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_results();
  inline void clear_has_max_results();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::google::protobuf::int64 max_results_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ScanRequest* default_instance_;
};
// -------------------------------------------------------------------

class ScanResponse : public ::google::protobuf::Message {
 public:
  ScanResponse();
  virtual ~ScanResponse();

  ScanResponse(const ScanResponse& from);

  inline ScanResponse& operator=(const ScanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanResponse& default_instance();

  void Swap(ScanResponse* other);

  // implements Message ----------------------------------------------

  ScanResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanResponse& from);
  void MergeFrom(const ScanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // repeated .proto.KeyValue rows = 2;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline const ::proto::KeyValue& rows(int index) const;
  inline ::proto::KeyValue* mutable_rows(int index);
  inline ::proto::KeyValue* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::KeyValue >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::KeyValue >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:proto.ScanResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::proto::KeyValue > rows_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ScanResponse* default_instance_;
};
// -------------------------------------------------------------------

class EndTransactionRequest : public ::google::protobuf::Message {
 public:
  EndTransactionRequest();
  virtual ~EndTransactionRequest();

  EndTransactionRequest(const EndTransactionRequest& from);

  inline EndTransactionRequest& operator=(const EndTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndTransactionRequest& default_instance();

  void Swap(EndTransactionRequest* other);

  // implements Message ----------------------------------------------

  EndTransactionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndTransactionRequest& from);
  void MergeFrom(const EndTransactionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional bool commit = 2;
  inline bool has_commit() const;
  inline void clear_commit();
  static const int kCommitFieldNumber = 2;
  inline bool commit() const;
  inline void set_commit(bool value);

  // optional .proto.SplitTrigger split_trigger = 3;
  inline bool has_split_trigger() const;
  inline void clear_split_trigger();
  static const int kSplitTriggerFieldNumber = 3;
  inline const ::proto::SplitTrigger& split_trigger() const;
  inline ::proto::SplitTrigger* mutable_split_trigger();
  inline ::proto::SplitTrigger* release_split_trigger();
  inline void set_allocated_split_trigger(::proto::SplitTrigger* split_trigger);

  // optional .proto.MergeTrigger merge_trigger = 4;
  inline bool has_merge_trigger() const;
  inline void clear_merge_trigger();
  static const int kMergeTriggerFieldNumber = 4;
  inline const ::proto::MergeTrigger& merge_trigger() const;
  inline ::proto::MergeTrigger* mutable_merge_trigger();
  inline ::proto::MergeTrigger* release_merge_trigger();
  inline void set_allocated_merge_trigger(::proto::MergeTrigger* merge_trigger);

  // @@protoc_insertion_point(class_scope:proto.EndTransactionRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_commit();
  inline void clear_has_commit();
  inline void set_has_split_trigger();
  inline void clear_has_split_trigger();
  inline void set_has_merge_trigger();
  inline void clear_has_merge_trigger();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::SplitTrigger* split_trigger_;
  ::proto::MergeTrigger* merge_trigger_;
  bool commit_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static EndTransactionRequest* default_instance_;
};
// -------------------------------------------------------------------

class EndTransactionResponse : public ::google::protobuf::Message {
 public:
  EndTransactionResponse();
  virtual ~EndTransactionResponse();

  EndTransactionResponse(const EndTransactionResponse& from);

  inline EndTransactionResponse& operator=(const EndTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndTransactionResponse& default_instance();

  void Swap(EndTransactionResponse* other);

  // implements Message ----------------------------------------------

  EndTransactionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndTransactionResponse& from);
  void MergeFrom(const EndTransactionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // optional int64 commit_wait = 2;
  inline bool has_commit_wait() const;
  inline void clear_commit_wait();
  static const int kCommitWaitFieldNumber = 2;
  inline ::google::protobuf::int64 commit_wait() const;
  inline void set_commit_wait(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.EndTransactionResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_commit_wait();
  inline void clear_has_commit_wait();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::google::protobuf::int64 commit_wait_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static EndTransactionResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReapQueueRequest : public ::google::protobuf::Message {
 public:
  ReapQueueRequest();
  virtual ~ReapQueueRequest();

  ReapQueueRequest(const ReapQueueRequest& from);

  inline ReapQueueRequest& operator=(const ReapQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReapQueueRequest& default_instance();

  void Swap(ReapQueueRequest* other);

  // implements Message ----------------------------------------------

  ReapQueueRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReapQueueRequest& from);
  void MergeFrom(const ReapQueueRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional int64 max_results = 2;
  inline bool has_max_results() const;
  inline void clear_max_results();
  static const int kMaxResultsFieldNumber = 2;
  inline ::google::protobuf::int64 max_results() const;
  inline void set_max_results(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.ReapQueueRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_results();
  inline void clear_has_max_results();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::google::protobuf::int64 max_results_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ReapQueueRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReapQueueResponse : public ::google::protobuf::Message {
 public:
  ReapQueueResponse();
  virtual ~ReapQueueResponse();

  ReapQueueResponse(const ReapQueueResponse& from);

  inline ReapQueueResponse& operator=(const ReapQueueResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReapQueueResponse& default_instance();

  void Swap(ReapQueueResponse* other);

  // implements Message ----------------------------------------------

  ReapQueueResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReapQueueResponse& from);
  void MergeFrom(const ReapQueueResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // repeated .proto.Value messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::proto::Value& messages(int index) const;
  inline ::proto::Value* mutable_messages(int index);
  inline ::proto::Value* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::Value >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::Value >*
      mutable_messages();

  // @@protoc_insertion_point(class_scope:proto.ReapQueueResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::proto::Value > messages_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ReapQueueResponse* default_instance_;
};
// -------------------------------------------------------------------

class EnqueueUpdateRequest : public ::google::protobuf::Message {
 public:
  EnqueueUpdateRequest();
  virtual ~EnqueueUpdateRequest();

  EnqueueUpdateRequest(const EnqueueUpdateRequest& from);

  inline EnqueueUpdateRequest& operator=(const EnqueueUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnqueueUpdateRequest& default_instance();

  void Swap(EnqueueUpdateRequest* other);

  // implements Message ----------------------------------------------

  EnqueueUpdateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnqueueUpdateRequest& from);
  void MergeFrom(const EnqueueUpdateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:proto.EnqueueUpdateRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static EnqueueUpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnqueueUpdateResponse : public ::google::protobuf::Message {
 public:
  EnqueueUpdateResponse();
  virtual ~EnqueueUpdateResponse();

  EnqueueUpdateResponse(const EnqueueUpdateResponse& from);

  inline EnqueueUpdateResponse& operator=(const EnqueueUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnqueueUpdateResponse& default_instance();

  void Swap(EnqueueUpdateResponse* other);

  // implements Message ----------------------------------------------

  EnqueueUpdateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnqueueUpdateResponse& from);
  void MergeFrom(const EnqueueUpdateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.EnqueueUpdateResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static EnqueueUpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class EnqueueMessageRequest : public ::google::protobuf::Message {
 public:
  EnqueueMessageRequest();
  virtual ~EnqueueMessageRequest();

  EnqueueMessageRequest(const EnqueueMessageRequest& from);

  inline EnqueueMessageRequest& operator=(const EnqueueMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnqueueMessageRequest& default_instance();

  void Swap(EnqueueMessageRequest* other);

  // implements Message ----------------------------------------------

  EnqueueMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnqueueMessageRequest& from);
  void MergeFrom(const EnqueueMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional .proto.Value msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::proto::Value& msg() const;
  inline ::proto::Value* mutable_msg();
  inline ::proto::Value* release_msg();
  inline void set_allocated_msg(::proto::Value* msg);

  // @@protoc_insertion_point(class_scope:proto.EnqueueMessageRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::Value* msg_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static EnqueueMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnqueueMessageResponse : public ::google::protobuf::Message {
 public:
  EnqueueMessageResponse();
  virtual ~EnqueueMessageResponse();

  EnqueueMessageResponse(const EnqueueMessageResponse& from);

  inline EnqueueMessageResponse& operator=(const EnqueueMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnqueueMessageResponse& default_instance();

  void Swap(EnqueueMessageResponse* other);

  // implements Message ----------------------------------------------

  EnqueueMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnqueueMessageResponse& from);
  void MergeFrom(const EnqueueMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.EnqueueMessageResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static EnqueueMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestUnion : public ::google::protobuf::Message {
 public:
  RequestUnion();
  virtual ~RequestUnion();

  RequestUnion(const RequestUnion& from);

  inline RequestUnion& operator=(const RequestUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUnion& default_instance();

  void Swap(RequestUnion* other);

  // implements Message ----------------------------------------------

  RequestUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUnion& from);
  void MergeFrom(const RequestUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ContainsRequest contains = 1;
  inline bool has_contains() const;
  inline void clear_contains();
  static const int kContainsFieldNumber = 1;
  inline const ::proto::ContainsRequest& contains() const;
  inline ::proto::ContainsRequest* mutable_contains();
  inline ::proto::ContainsRequest* release_contains();
  inline void set_allocated_contains(::proto::ContainsRequest* contains);

  // optional .proto.GetRequest get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline const ::proto::GetRequest& get() const;
  inline ::proto::GetRequest* mutable_get();
  inline ::proto::GetRequest* release_get();
  inline void set_allocated_get(::proto::GetRequest* get);

  // optional .proto.PutRequest put = 3;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 3;
  inline const ::proto::PutRequest& put() const;
  inline ::proto::PutRequest* mutable_put();
  inline ::proto::PutRequest* release_put();
  inline void set_allocated_put(::proto::PutRequest* put);

  // optional .proto.ConditionalPutRequest conditional_put = 4;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 4;
  inline const ::proto::ConditionalPutRequest& conditional_put() const;
  inline ::proto::ConditionalPutRequest* mutable_conditional_put();
  inline ::proto::ConditionalPutRequest* release_conditional_put();
  inline void set_allocated_conditional_put(::proto::ConditionalPutRequest* conditional_put);

  // optional .proto.IncrementRequest increment = 5;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 5;
  inline const ::proto::IncrementRequest& increment() const;
  inline ::proto::IncrementRequest* mutable_increment();
  inline ::proto::IncrementRequest* release_increment();
  inline void set_allocated_increment(::proto::IncrementRequest* increment);

  // optional .proto.DeleteRequest delete = 6;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 6;
  inline const ::proto::DeleteRequest& delete_() const;
  inline ::proto::DeleteRequest* mutable_delete_();
  inline ::proto::DeleteRequest* release_delete_();
  inline void set_allocated_delete_(::proto::DeleteRequest* delete_);

  // optional .proto.DeleteRangeRequest delete_range = 7;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 7;
  inline const ::proto::DeleteRangeRequest& delete_range() const;
  inline ::proto::DeleteRangeRequest* mutable_delete_range();
  inline ::proto::DeleteRangeRequest* release_delete_range();
  inline void set_allocated_delete_range(::proto::DeleteRangeRequest* delete_range);

  // optional .proto.ScanRequest scan = 8;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 8;
  inline const ::proto::ScanRequest& scan() const;
  inline ::proto::ScanRequest* mutable_scan();
  inline ::proto::ScanRequest* release_scan();
  inline void set_allocated_scan(::proto::ScanRequest* scan);

  // optional .proto.EndTransactionRequest end_transaction = 9;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  inline const ::proto::EndTransactionRequest& end_transaction() const;
  inline ::proto::EndTransactionRequest* mutable_end_transaction();
  inline ::proto::EndTransactionRequest* release_end_transaction();
  inline void set_allocated_end_transaction(::proto::EndTransactionRequest* end_transaction);

  // optional .proto.ReapQueueRequest reap_queue = 10;
  inline bool has_reap_queue() const;
  inline void clear_reap_queue();
  static const int kReapQueueFieldNumber = 10;
  inline const ::proto::ReapQueueRequest& reap_queue() const;
  inline ::proto::ReapQueueRequest* mutable_reap_queue();
  inline ::proto::ReapQueueRequest* release_reap_queue();
  inline void set_allocated_reap_queue(::proto::ReapQueueRequest* reap_queue);

  // optional .proto.EnqueueUpdateRequest enqueue_update = 11;
  inline bool has_enqueue_update() const;
  inline void clear_enqueue_update();
  static const int kEnqueueUpdateFieldNumber = 11;
  inline const ::proto::EnqueueUpdateRequest& enqueue_update() const;
  inline ::proto::EnqueueUpdateRequest* mutable_enqueue_update();
  inline ::proto::EnqueueUpdateRequest* release_enqueue_update();
  inline void set_allocated_enqueue_update(::proto::EnqueueUpdateRequest* enqueue_update);

  // optional .proto.EnqueueMessageRequest enqueue_message = 12;
  inline bool has_enqueue_message() const;
  inline void clear_enqueue_message();
  static const int kEnqueueMessageFieldNumber = 12;
  inline const ::proto::EnqueueMessageRequest& enqueue_message() const;
  inline ::proto::EnqueueMessageRequest* mutable_enqueue_message();
  inline ::proto::EnqueueMessageRequest* release_enqueue_message();
  inline void set_allocated_enqueue_message(::proto::EnqueueMessageRequest* enqueue_message);

  // @@protoc_insertion_point(class_scope:proto.RequestUnion)
 private:
  inline void set_has_contains();
  inline void clear_has_contains();
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_put();
  inline void clear_has_put();
  inline void set_has_conditional_put();
  inline void clear_has_conditional_put();
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_delete_range();
  inline void clear_has_delete_range();
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_end_transaction();
  inline void clear_has_end_transaction();
  inline void set_has_reap_queue();
  inline void clear_has_reap_queue();
  inline void set_has_enqueue_update();
  inline void clear_has_enqueue_update();
  inline void set_has_enqueue_message();
  inline void clear_has_enqueue_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ContainsRequest* contains_;
  ::proto::GetRequest* get_;
  ::proto::PutRequest* put_;
  ::proto::ConditionalPutRequest* conditional_put_;
  ::proto::IncrementRequest* increment_;
  ::proto::DeleteRequest* delete__;
  ::proto::DeleteRangeRequest* delete_range_;
  ::proto::ScanRequest* scan_;
  ::proto::EndTransactionRequest* end_transaction_;
  ::proto::ReapQueueRequest* reap_queue_;
  ::proto::EnqueueUpdateRequest* enqueue_update_;
  ::proto::EnqueueMessageRequest* enqueue_message_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static RequestUnion* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUnion : public ::google::protobuf::Message {
 public:
  ResponseUnion();
  virtual ~ResponseUnion();

  ResponseUnion(const ResponseUnion& from);

  inline ResponseUnion& operator=(const ResponseUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseUnion& default_instance();

  void Swap(ResponseUnion* other);

  // implements Message ----------------------------------------------

  ResponseUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseUnion& from);
  void MergeFrom(const ResponseUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ContainsResponse contains = 1;
  inline bool has_contains() const;
  inline void clear_contains();
  static const int kContainsFieldNumber = 1;
  inline const ::proto::ContainsResponse& contains() const;
  inline ::proto::ContainsResponse* mutable_contains();
  inline ::proto::ContainsResponse* release_contains();
  inline void set_allocated_contains(::proto::ContainsResponse* contains);

  // optional .proto.GetResponse get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline const ::proto::GetResponse& get() const;
  inline ::proto::GetResponse* mutable_get();
  inline ::proto::GetResponse* release_get();
  inline void set_allocated_get(::proto::GetResponse* get);

  // optional .proto.PutResponse put = 3;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 3;
  inline const ::proto::PutResponse& put() const;
  inline ::proto::PutResponse* mutable_put();
  inline ::proto::PutResponse* release_put();
  inline void set_allocated_put(::proto::PutResponse* put);

  // optional .proto.ConditionalPutResponse conditional_put = 4;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 4;
  inline const ::proto::ConditionalPutResponse& conditional_put() const;
  inline ::proto::ConditionalPutResponse* mutable_conditional_put();
  inline ::proto::ConditionalPutResponse* release_conditional_put();
  inline void set_allocated_conditional_put(::proto::ConditionalPutResponse* conditional_put);

  // optional .proto.IncrementResponse increment = 5;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 5;
  inline const ::proto::IncrementResponse& increment() const;
  inline ::proto::IncrementResponse* mutable_increment();
  inline ::proto::IncrementResponse* release_increment();
  inline void set_allocated_increment(::proto::IncrementResponse* increment);

  // optional .proto.DeleteResponse delete = 6;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 6;
  inline const ::proto::DeleteResponse& delete_() const;
  inline ::proto::DeleteResponse* mutable_delete_();
  inline ::proto::DeleteResponse* release_delete_();
  inline void set_allocated_delete_(::proto::DeleteResponse* delete_);

  // optional .proto.DeleteRangeResponse delete_range = 7;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 7;
  inline const ::proto::DeleteRangeResponse& delete_range() const;
  inline ::proto::DeleteRangeResponse* mutable_delete_range();
  inline ::proto::DeleteRangeResponse* release_delete_range();
  inline void set_allocated_delete_range(::proto::DeleteRangeResponse* delete_range);

  // optional .proto.ScanResponse scan = 8;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 8;
  inline const ::proto::ScanResponse& scan() const;
  inline ::proto::ScanResponse* mutable_scan();
  inline ::proto::ScanResponse* release_scan();
  inline void set_allocated_scan(::proto::ScanResponse* scan);

  // optional .proto.EndTransactionResponse end_transaction = 9;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  inline const ::proto::EndTransactionResponse& end_transaction() const;
  inline ::proto::EndTransactionResponse* mutable_end_transaction();
  inline ::proto::EndTransactionResponse* release_end_transaction();
  inline void set_allocated_end_transaction(::proto::EndTransactionResponse* end_transaction);

  // optional .proto.ReapQueueResponse reap_queue = 10;
  inline bool has_reap_queue() const;
  inline void clear_reap_queue();
  static const int kReapQueueFieldNumber = 10;
  inline const ::proto::ReapQueueResponse& reap_queue() const;
  inline ::proto::ReapQueueResponse* mutable_reap_queue();
  inline ::proto::ReapQueueResponse* release_reap_queue();
  inline void set_allocated_reap_queue(::proto::ReapQueueResponse* reap_queue);

  // optional .proto.EnqueueUpdateResponse enqueue_update = 11;
  inline bool has_enqueue_update() const;
  inline void clear_enqueue_update();
  static const int kEnqueueUpdateFieldNumber = 11;
  inline const ::proto::EnqueueUpdateResponse& enqueue_update() const;
  inline ::proto::EnqueueUpdateResponse* mutable_enqueue_update();
  inline ::proto::EnqueueUpdateResponse* release_enqueue_update();
  inline void set_allocated_enqueue_update(::proto::EnqueueUpdateResponse* enqueue_update);

  // optional .proto.EnqueueMessageResponse enqueue_message = 12;
  inline bool has_enqueue_message() const;
  inline void clear_enqueue_message();
  static const int kEnqueueMessageFieldNumber = 12;
  inline const ::proto::EnqueueMessageResponse& enqueue_message() const;
  inline ::proto::EnqueueMessageResponse* mutable_enqueue_message();
  inline ::proto::EnqueueMessageResponse* release_enqueue_message();
  inline void set_allocated_enqueue_message(::proto::EnqueueMessageResponse* enqueue_message);

  // @@protoc_insertion_point(class_scope:proto.ResponseUnion)
 private:
  inline void set_has_contains();
  inline void clear_has_contains();
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_put();
  inline void clear_has_put();
  inline void set_has_conditional_put();
  inline void clear_has_conditional_put();
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_delete_range();
  inline void clear_has_delete_range();
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_end_transaction();
  inline void clear_has_end_transaction();
  inline void set_has_reap_queue();
  inline void clear_has_reap_queue();
  inline void set_has_enqueue_update();
  inline void clear_has_enqueue_update();
  inline void set_has_enqueue_message();
  inline void clear_has_enqueue_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ContainsResponse* contains_;
  ::proto::GetResponse* get_;
  ::proto::PutResponse* put_;
  ::proto::ConditionalPutResponse* conditional_put_;
  ::proto::IncrementResponse* increment_;
  ::proto::DeleteResponse* delete__;
  ::proto::DeleteRangeResponse* delete_range_;
  ::proto::ScanResponse* scan_;
  ::proto::EndTransactionResponse* end_transaction_;
  ::proto::ReapQueueResponse* reap_queue_;
  ::proto::EnqueueUpdateResponse* enqueue_update_;
  ::proto::EnqueueMessageResponse* enqueue_message_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static ResponseUnion* default_instance_;
};
// -------------------------------------------------------------------

class BatchRequest : public ::google::protobuf::Message {
 public:
  BatchRequest();
  virtual ~BatchRequest();

  BatchRequest(const BatchRequest& from);

  inline BatchRequest& operator=(const BatchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchRequest& default_instance();

  void Swap(BatchRequest* other);

  // implements Message ----------------------------------------------

  BatchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchRequest& from);
  void MergeFrom(const BatchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // repeated .proto.RequestUnion requests = 2;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 2;
  inline const ::proto::RequestUnion& requests(int index) const;
  inline ::proto::RequestUnion* mutable_requests(int index);
  inline ::proto::RequestUnion* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::RequestUnion >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::RequestUnion >*
      mutable_requests();

  // @@protoc_insertion_point(class_scope:proto.BatchRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::proto::RequestUnion > requests_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static BatchRequest* default_instance_;
};
// -------------------------------------------------------------------

class BatchResponse : public ::google::protobuf::Message {
 public:
  BatchResponse();
  virtual ~BatchResponse();

  BatchResponse(const BatchResponse& from);

  inline BatchResponse& operator=(const BatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchResponse& default_instance();

  void Swap(BatchResponse* other);

  // implements Message ----------------------------------------------

  BatchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchResponse& from);
  void MergeFrom(const BatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // repeated .proto.ResponseUnion responses = 2;
  inline int responses_size() const;
  inline void clear_responses();
  static const int kResponsesFieldNumber = 2;
  inline const ::proto::ResponseUnion& responses(int index) const;
  inline ::proto::ResponseUnion* mutable_responses(int index);
  inline ::proto::ResponseUnion* add_responses();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::ResponseUnion >&
      responses() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::ResponseUnion >*
      mutable_responses();

  // @@protoc_insertion_point(class_scope:proto.BatchResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::proto::ResponseUnion > responses_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static BatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class AdminSplitRequest : public ::google::protobuf::Message {
 public:
  AdminSplitRequest();
  virtual ~AdminSplitRequest();

  AdminSplitRequest(const AdminSplitRequest& from);

  inline AdminSplitRequest& operator=(const AdminSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminSplitRequest& default_instance();

  void Swap(AdminSplitRequest* other);

  // implements Message ----------------------------------------------

  AdminSplitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminSplitRequest& from);
  void MergeFrom(const AdminSplitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional bytes split_key = 2;
  inline bool has_split_key() const;
  inline void clear_split_key();
  static const int kSplitKeyFieldNumber = 2;
  inline const ::std::string& split_key() const;
  inline void set_split_key(const ::std::string& value);
  inline void set_split_key(const char* value);
  inline void set_split_key(const void* value, size_t size);
  inline ::std::string* mutable_split_key();
  inline ::std::string* release_split_key();
  inline void set_allocated_split_key(::std::string* split_key);

  // @@protoc_insertion_point(class_scope:proto.AdminSplitRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_split_key();
  inline void clear_has_split_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::std::string* split_key_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static AdminSplitRequest* default_instance_;
};
// -------------------------------------------------------------------

class AdminSplitResponse : public ::google::protobuf::Message {
 public:
  AdminSplitResponse();
  virtual ~AdminSplitResponse();

  AdminSplitResponse(const AdminSplitResponse& from);

  inline AdminSplitResponse& operator=(const AdminSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminSplitResponse& default_instance();

  void Swap(AdminSplitResponse* other);

  // implements Message ----------------------------------------------

  AdminSplitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminSplitResponse& from);
  void MergeFrom(const AdminSplitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.AdminSplitResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static AdminSplitResponse* default_instance_;
};
// -------------------------------------------------------------------

class AdminMergeRequest : public ::google::protobuf::Message {
 public:
  AdminMergeRequest();
  virtual ~AdminMergeRequest();

  AdminMergeRequest(const AdminMergeRequest& from);

  inline AdminMergeRequest& operator=(const AdminMergeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminMergeRequest& default_instance();

  void Swap(AdminMergeRequest* other);

  // implements Message ----------------------------------------------

  AdminMergeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminMergeRequest& from);
  void MergeFrom(const AdminMergeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::RequestHeader& header() const;
  inline ::proto::RequestHeader* mutable_header();
  inline ::proto::RequestHeader* release_header();
  inline void set_allocated_header(::proto::RequestHeader* header);

  // optional .proto.RangeDescriptor subsumed_range = 2;
  inline bool has_subsumed_range() const;
  inline void clear_subsumed_range();
  static const int kSubsumedRangeFieldNumber = 2;
  inline const ::proto::RangeDescriptor& subsumed_range() const;
  inline ::proto::RangeDescriptor* mutable_subsumed_range();
  inline ::proto::RangeDescriptor* release_subsumed_range();
  inline void set_allocated_subsumed_range(::proto::RangeDescriptor* subsumed_range);

  // @@protoc_insertion_point(class_scope:proto.AdminMergeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_subsumed_range();
  inline void clear_has_subsumed_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::RequestHeader* header_;
  ::proto::RangeDescriptor* subsumed_range_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static AdminMergeRequest* default_instance_;
};
// -------------------------------------------------------------------

class AdminMergeResponse : public ::google::protobuf::Message {
 public:
  AdminMergeResponse();
  virtual ~AdminMergeResponse();

  AdminMergeResponse(const AdminMergeResponse& from);

  inline AdminMergeResponse& operator=(const AdminMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminMergeResponse& default_instance();

  void Swap(AdminMergeResponse* other);

  // implements Message ----------------------------------------------

  AdminMergeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminMergeResponse& from);
  void MergeFrom(const AdminMergeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::proto::ResponseHeader& header() const;
  inline ::proto::ResponseHeader* mutable_header();
  inline ::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:proto.AdminMergeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_api_2eproto();
  friend void protobuf_AssignDesc_api_2eproto();
  friend void protobuf_ShutdownFile_api_2eproto();

  void InitAsDefaultInstance();
  static AdminMergeResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientCmdID

// optional int64 wall_time = 1;
inline bool ClientCmdID::has_wall_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCmdID::set_has_wall_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCmdID::clear_has_wall_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCmdID::clear_wall_time() {
  wall_time_ = GOOGLE_LONGLONG(0);
  clear_has_wall_time();
}
inline ::google::protobuf::int64 ClientCmdID::wall_time() const {
  // @@protoc_insertion_point(field_get:proto.ClientCmdID.wall_time)
  return wall_time_;
}
inline void ClientCmdID::set_wall_time(::google::protobuf::int64 value) {
  set_has_wall_time();
  wall_time_ = value;
  // @@protoc_insertion_point(field_set:proto.ClientCmdID.wall_time)
}

// optional int64 random = 2;
inline bool ClientCmdID::has_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientCmdID::set_has_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientCmdID::clear_has_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientCmdID::clear_random() {
  random_ = GOOGLE_LONGLONG(0);
  clear_has_random();
}
inline ::google::protobuf::int64 ClientCmdID::random() const {
  // @@protoc_insertion_point(field_get:proto.ClientCmdID.random)
  return random_;
}
inline void ClientCmdID::set_random(::google::protobuf::int64 value) {
  set_has_random();
  random_ = value;
  // @@protoc_insertion_point(field_set:proto.ClientCmdID.random)
}

// -------------------------------------------------------------------

// RequestHeader

// optional .proto.Timestamp timestamp = 1;
inline bool RequestHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::proto::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::proto::Timestamp& RequestHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::proto::Timestamp* RequestHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:proto.RequestHeader.timestamp)
  return timestamp_;
}
inline ::proto::Timestamp* RequestHeader::release_timestamp() {
  clear_has_timestamp();
  ::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_timestamp(::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestHeader.timestamp)
}

// optional .proto.ClientCmdID cmd_id = 2;
inline bool RequestHeader::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestHeader::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestHeader::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestHeader::clear_cmd_id() {
  if (cmd_id_ != NULL) cmd_id_->::proto::ClientCmdID::Clear();
  clear_has_cmd_id();
}
inline const ::proto::ClientCmdID& RequestHeader::cmd_id() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.cmd_id)
  return cmd_id_ != NULL ? *cmd_id_ : *default_instance_->cmd_id_;
}
inline ::proto::ClientCmdID* RequestHeader::mutable_cmd_id() {
  set_has_cmd_id();
  if (cmd_id_ == NULL) cmd_id_ = new ::proto::ClientCmdID;
  // @@protoc_insertion_point(field_mutable:proto.RequestHeader.cmd_id)
  return cmd_id_;
}
inline ::proto::ClientCmdID* RequestHeader::release_cmd_id() {
  clear_has_cmd_id();
  ::proto::ClientCmdID* temp = cmd_id_;
  cmd_id_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_cmd_id(::proto::ClientCmdID* cmd_id) {
  delete cmd_id_;
  cmd_id_ = cmd_id;
  if (cmd_id) {
    set_has_cmd_id();
  } else {
    clear_has_cmd_id();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestHeader.cmd_id)
}

// optional bytes key = 3;
inline bool RequestHeader::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestHeader::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestHeader::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestHeader::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RequestHeader::key() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.key)
  return *key_;
}
inline void RequestHeader::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.RequestHeader.key)
}
inline void RequestHeader::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.RequestHeader.key)
}
inline void RequestHeader::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.RequestHeader.key)
}
inline ::std::string* RequestHeader::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.RequestHeader.key)
  return key_;
}
inline ::std::string* RequestHeader::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestHeader::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestHeader.key)
}

// optional bytes end_key = 4;
inline bool RequestHeader::has_end_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestHeader::set_has_end_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestHeader::clear_has_end_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestHeader::clear_end_key() {
  if (end_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_->clear();
  }
  clear_has_end_key();
}
inline const ::std::string& RequestHeader::end_key() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.end_key)
  return *end_key_;
}
inline void RequestHeader::set_end_key(const ::std::string& value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.RequestHeader.end_key)
}
inline void RequestHeader::set_end_key(const char* value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.RequestHeader.end_key)
}
inline void RequestHeader::set_end_key(const void* value, size_t size) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.RequestHeader.end_key)
}
inline ::std::string* RequestHeader::mutable_end_key() {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.RequestHeader.end_key)
  return end_key_;
}
inline ::std::string* RequestHeader::release_end_key() {
  clear_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_key_;
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestHeader::set_allocated_end_key(::std::string* end_key) {
  if (end_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_key_;
  }
  if (end_key) {
    set_has_end_key();
    end_key_ = end_key;
  } else {
    clear_has_end_key();
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestHeader.end_key)
}

// optional string user = 5;
inline bool RequestHeader::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestHeader::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestHeader::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestHeader::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& RequestHeader::user() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.user)
  return *user_;
}
inline void RequestHeader::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:proto.RequestHeader.user)
}
inline void RequestHeader::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.RequestHeader.user)
}
inline void RequestHeader::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.RequestHeader.user)
}
inline ::std::string* RequestHeader::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.RequestHeader.user)
  return user_;
}
inline ::std::string* RequestHeader::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestHeader::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestHeader.user)
}

// optional .proto.Replica replica = 6;
inline bool RequestHeader::has_replica() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestHeader::set_has_replica() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestHeader::clear_has_replica() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestHeader::clear_replica() {
  if (replica_ != NULL) replica_->::proto::Replica::Clear();
  clear_has_replica();
}
inline const ::proto::Replica& RequestHeader::replica() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.replica)
  return replica_ != NULL ? *replica_ : *default_instance_->replica_;
}
inline ::proto::Replica* RequestHeader::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) replica_ = new ::proto::Replica;
  // @@protoc_insertion_point(field_mutable:proto.RequestHeader.replica)
  return replica_;
}
inline ::proto::Replica* RequestHeader::release_replica() {
  clear_has_replica();
  ::proto::Replica* temp = replica_;
  replica_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_replica(::proto::Replica* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestHeader.replica)
}

// optional int64 raft_id = 7;
inline bool RequestHeader::has_raft_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestHeader::set_has_raft_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestHeader::clear_has_raft_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestHeader::clear_raft_id() {
  raft_id_ = GOOGLE_LONGLONG(0);
  clear_has_raft_id();
}
inline ::google::protobuf::int64 RequestHeader::raft_id() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.raft_id)
  return raft_id_;
}
inline void RequestHeader::set_raft_id(::google::protobuf::int64 value) {
  set_has_raft_id();
  raft_id_ = value;
  // @@protoc_insertion_point(field_set:proto.RequestHeader.raft_id)
}

// optional int32 user_priority = 8 [default = 1];
inline bool RequestHeader::has_user_priority() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestHeader::set_has_user_priority() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestHeader::clear_has_user_priority() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestHeader::clear_user_priority() {
  user_priority_ = 1;
  clear_has_user_priority();
}
inline ::google::protobuf::int32 RequestHeader::user_priority() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.user_priority)
  return user_priority_;
}
inline void RequestHeader::set_user_priority(::google::protobuf::int32 value) {
  set_has_user_priority();
  user_priority_ = value;
  // @@protoc_insertion_point(field_set:proto.RequestHeader.user_priority)
}

// optional .proto.Transaction txn = 9;
inline bool RequestHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestHeader::clear_txn() {
  if (txn_ != NULL) txn_->::proto::Transaction::Clear();
  clear_has_txn();
}
inline const ::proto::Transaction& RequestHeader::txn() const {
  // @@protoc_insertion_point(field_get:proto.RequestHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
inline ::proto::Transaction* RequestHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) txn_ = new ::proto::Transaction;
  // @@protoc_insertion_point(field_mutable:proto.RequestHeader.txn)
  return txn_;
}
inline ::proto::Transaction* RequestHeader::release_txn() {
  clear_has_txn();
  ::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline void RequestHeader::set_allocated_txn(::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestHeader.txn)
}

// -------------------------------------------------------------------

// ResponseHeader

// optional .proto.Error error = 1;
inline bool ResponseHeader::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseHeader::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseHeader::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseHeader::clear_error() {
  if (error_ != NULL) error_->::proto::Error::Clear();
  clear_has_error();
}
inline const ::proto::Error& ResponseHeader::error() const {
  // @@protoc_insertion_point(field_get:proto.ResponseHeader.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::proto::Error* ResponseHeader::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::proto::Error;
  // @@protoc_insertion_point(field_mutable:proto.ResponseHeader.error)
  return error_;
}
inline ::proto::Error* ResponseHeader::release_error() {
  clear_has_error();
  ::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_error(::proto::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseHeader.error)
}

// optional .proto.Timestamp timestamp = 2;
inline bool ResponseHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::proto::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::proto::Timestamp& ResponseHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.ResponseHeader.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::proto::Timestamp* ResponseHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:proto.ResponseHeader.timestamp)
  return timestamp_;
}
inline ::proto::Timestamp* ResponseHeader::release_timestamp() {
  clear_has_timestamp();
  ::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_timestamp(::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseHeader.timestamp)
}

// optional .proto.Transaction txn = 3;
inline bool ResponseHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseHeader::clear_txn() {
  if (txn_ != NULL) txn_->::proto::Transaction::Clear();
  clear_has_txn();
}
inline const ::proto::Transaction& ResponseHeader::txn() const {
  // @@protoc_insertion_point(field_get:proto.ResponseHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
inline ::proto::Transaction* ResponseHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) txn_ = new ::proto::Transaction;
  // @@protoc_insertion_point(field_mutable:proto.ResponseHeader.txn)
  return txn_;
}
inline ::proto::Transaction* ResponseHeader::release_txn() {
  clear_has_txn();
  ::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_txn(::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseHeader.txn)
}

// -------------------------------------------------------------------

// ContainsRequest

// optional .proto.RequestHeader header = 1;
inline bool ContainsRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainsRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainsRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainsRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& ContainsRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.ContainsRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* ContainsRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.ContainsRequest.header)
  return header_;
}
inline ::proto::RequestHeader* ContainsRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ContainsRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ContainsRequest.header)
}

// -------------------------------------------------------------------

// ContainsResponse

// optional .proto.ResponseHeader header = 1;
inline bool ContainsResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainsResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainsResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainsResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& ContainsResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.ContainsResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* ContainsResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.ContainsResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* ContainsResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ContainsResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ContainsResponse.header)
}

// optional bool exists = 2;
inline bool ContainsResponse::has_exists() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainsResponse::set_has_exists() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainsResponse::clear_has_exists() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainsResponse::clear_exists() {
  exists_ = false;
  clear_has_exists();
}
inline bool ContainsResponse::exists() const {
  // @@protoc_insertion_point(field_get:proto.ContainsResponse.exists)
  return exists_;
}
inline void ContainsResponse::set_exists(bool value) {
  set_has_exists();
  exists_ = value;
  // @@protoc_insertion_point(field_set:proto.ContainsResponse.exists)
}

// -------------------------------------------------------------------

// GetRequest

// optional .proto.RequestHeader header = 1;
inline bool GetRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& GetRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.GetRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* GetRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.GetRequest.header)
  return header_;
}
inline ::proto::RequestHeader* GetRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.GetRequest.header)
}

// -------------------------------------------------------------------

// GetResponse

// optional .proto.ResponseHeader header = 1;
inline bool GetResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& GetResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.GetResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* GetResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.GetResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* GetResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.GetResponse.header)
}

// optional .proto.Value value = 2;
inline bool GetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetResponse::clear_value() {
  if (value_ != NULL) value_->::proto::Value::Clear();
  clear_has_value();
}
inline const ::proto::Value& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:proto.GetResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::proto::Value* GetResponse::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::proto::Value;
  // @@protoc_insertion_point(field_mutable:proto.GetResponse.value)
  return value_;
}
inline ::proto::Value* GetResponse::release_value() {
  clear_has_value();
  ::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void GetResponse::set_allocated_value(::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.GetResponse.value)
}

// -------------------------------------------------------------------

// PutRequest

// optional .proto.RequestHeader header = 1;
inline bool PutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PutRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& PutRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.PutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* PutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.PutRequest.header)
  return header_;
}
inline ::proto::RequestHeader* PutRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PutRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PutRequest.header)
}

// optional .proto.Value value = 2;
inline bool PutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PutRequest::clear_value() {
  if (value_ != NULL) value_->::proto::Value::Clear();
  clear_has_value();
}
inline const ::proto::Value& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:proto.PutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::proto::Value* PutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::proto::Value;
  // @@protoc_insertion_point(field_mutable:proto.PutRequest.value)
  return value_;
}
inline ::proto::Value* PutRequest::release_value() {
  clear_has_value();
  ::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void PutRequest::set_allocated_value(::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PutRequest.value)
}

// -------------------------------------------------------------------

// PutResponse

// optional .proto.ResponseHeader header = 1;
inline bool PutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PutResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& PutResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.PutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* PutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.PutResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* PutResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PutResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PutResponse.header)
}

// -------------------------------------------------------------------

// ConditionalPutRequest

// optional .proto.RequestHeader header = 1;
inline bool ConditionalPutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionalPutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionalPutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionalPutRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& ConditionalPutRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.ConditionalPutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* ConditionalPutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.ConditionalPutRequest.header)
  return header_;
}
inline ::proto::RequestHeader* ConditionalPutRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ConditionalPutRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ConditionalPutRequest.header)
}

// optional .proto.Value value = 2;
inline bool ConditionalPutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConditionalPutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConditionalPutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConditionalPutRequest::clear_value() {
  if (value_ != NULL) value_->::proto::Value::Clear();
  clear_has_value();
}
inline const ::proto::Value& ConditionalPutRequest::value() const {
  // @@protoc_insertion_point(field_get:proto.ConditionalPutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::proto::Value* ConditionalPutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::proto::Value;
  // @@protoc_insertion_point(field_mutable:proto.ConditionalPutRequest.value)
  return value_;
}
inline ::proto::Value* ConditionalPutRequest::release_value() {
  clear_has_value();
  ::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ConditionalPutRequest::set_allocated_value(::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ConditionalPutRequest.value)
}

// optional .proto.Value exp_value = 3;
inline bool ConditionalPutRequest::has_exp_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConditionalPutRequest::set_has_exp_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConditionalPutRequest::clear_has_exp_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConditionalPutRequest::clear_exp_value() {
  if (exp_value_ != NULL) exp_value_->::proto::Value::Clear();
  clear_has_exp_value();
}
inline const ::proto::Value& ConditionalPutRequest::exp_value() const {
  // @@protoc_insertion_point(field_get:proto.ConditionalPutRequest.exp_value)
  return exp_value_ != NULL ? *exp_value_ : *default_instance_->exp_value_;
}
inline ::proto::Value* ConditionalPutRequest::mutable_exp_value() {
  set_has_exp_value();
  if (exp_value_ == NULL) exp_value_ = new ::proto::Value;
  // @@protoc_insertion_point(field_mutable:proto.ConditionalPutRequest.exp_value)
  return exp_value_;
}
inline ::proto::Value* ConditionalPutRequest::release_exp_value() {
  clear_has_exp_value();
  ::proto::Value* temp = exp_value_;
  exp_value_ = NULL;
  return temp;
}
inline void ConditionalPutRequest::set_allocated_exp_value(::proto::Value* exp_value) {
  delete exp_value_;
  exp_value_ = exp_value;
  if (exp_value) {
    set_has_exp_value();
  } else {
    clear_has_exp_value();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ConditionalPutRequest.exp_value)
}

// -------------------------------------------------------------------

// ConditionalPutResponse

// optional .proto.ResponseHeader header = 1;
inline bool ConditionalPutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionalPutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionalPutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionalPutResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& ConditionalPutResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.ConditionalPutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* ConditionalPutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.ConditionalPutResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* ConditionalPutResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ConditionalPutResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ConditionalPutResponse.header)
}

// -------------------------------------------------------------------

// IncrementRequest

// optional .proto.RequestHeader header = 1;
inline bool IncrementRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IncrementRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IncrementRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IncrementRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& IncrementRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.IncrementRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* IncrementRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.IncrementRequest.header)
  return header_;
}
inline ::proto::RequestHeader* IncrementRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void IncrementRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.IncrementRequest.header)
}

// optional int64 increment = 2;
inline bool IncrementRequest::has_increment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IncrementRequest::set_has_increment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IncrementRequest::clear_has_increment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IncrementRequest::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
  clear_has_increment();
}
inline ::google::protobuf::int64 IncrementRequest::increment() const {
  // @@protoc_insertion_point(field_get:proto.IncrementRequest.increment)
  return increment_;
}
inline void IncrementRequest::set_increment(::google::protobuf::int64 value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:proto.IncrementRequest.increment)
}

// -------------------------------------------------------------------

// IncrementResponse

// optional .proto.ResponseHeader header = 1;
inline bool IncrementResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IncrementResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IncrementResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IncrementResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& IncrementResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.IncrementResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* IncrementResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.IncrementResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* IncrementResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void IncrementResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.IncrementResponse.header)
}

// optional int64 new_value = 2;
inline bool IncrementResponse::has_new_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IncrementResponse::set_has_new_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IncrementResponse::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IncrementResponse::clear_new_value() {
  new_value_ = GOOGLE_LONGLONG(0);
  clear_has_new_value();
}
inline ::google::protobuf::int64 IncrementResponse::new_value() const {
  // @@protoc_insertion_point(field_get:proto.IncrementResponse.new_value)
  return new_value_;
}
inline void IncrementResponse::set_new_value(::google::protobuf::int64 value) {
  set_has_new_value();
  new_value_ = value;
  // @@protoc_insertion_point(field_set:proto.IncrementResponse.new_value)
}

// -------------------------------------------------------------------

// DeleteRequest

// optional .proto.RequestHeader header = 1;
inline bool DeleteRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& DeleteRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.DeleteRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* DeleteRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.DeleteRequest.header)
  return header_;
}
inline ::proto::RequestHeader* DeleteRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.DeleteRequest.header)
}

// -------------------------------------------------------------------

// DeleteResponse

// optional .proto.ResponseHeader header = 1;
inline bool DeleteResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& DeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.DeleteResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* DeleteResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.DeleteResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* DeleteResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.DeleteResponse.header)
}

// -------------------------------------------------------------------

// DeleteRangeRequest

// optional .proto.RequestHeader header = 1;
inline bool DeleteRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRangeRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& DeleteRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.DeleteRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* DeleteRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.DeleteRangeRequest.header)
  return header_;
}
inline ::proto::RequestHeader* DeleteRangeRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRangeRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.DeleteRangeRequest.header)
}

// optional int64 max_entries_to_delete = 2;
inline bool DeleteRangeRequest::has_max_entries_to_delete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteRangeRequest::set_has_max_entries_to_delete() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteRangeRequest::clear_has_max_entries_to_delete() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteRangeRequest::clear_max_entries_to_delete() {
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  clear_has_max_entries_to_delete();
}
inline ::google::protobuf::int64 DeleteRangeRequest::max_entries_to_delete() const {
  // @@protoc_insertion_point(field_get:proto.DeleteRangeRequest.max_entries_to_delete)
  return max_entries_to_delete_;
}
inline void DeleteRangeRequest::set_max_entries_to_delete(::google::protobuf::int64 value) {
  set_has_max_entries_to_delete();
  max_entries_to_delete_ = value;
  // @@protoc_insertion_point(field_set:proto.DeleteRangeRequest.max_entries_to_delete)
}

// -------------------------------------------------------------------

// DeleteRangeResponse

// optional .proto.ResponseHeader header = 1;
inline bool DeleteRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRangeResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& DeleteRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.DeleteRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* DeleteRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.DeleteRangeResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* DeleteRangeResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRangeResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.DeleteRangeResponse.header)
}

// optional int64 num_deleted = 2;
inline bool DeleteRangeResponse::has_num_deleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteRangeResponse::set_has_num_deleted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteRangeResponse::clear_has_num_deleted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteRangeResponse::clear_num_deleted() {
  num_deleted_ = GOOGLE_LONGLONG(0);
  clear_has_num_deleted();
}
inline ::google::protobuf::int64 DeleteRangeResponse::num_deleted() const {
  // @@protoc_insertion_point(field_get:proto.DeleteRangeResponse.num_deleted)
  return num_deleted_;
}
inline void DeleteRangeResponse::set_num_deleted(::google::protobuf::int64 value) {
  set_has_num_deleted();
  num_deleted_ = value;
  // @@protoc_insertion_point(field_set:proto.DeleteRangeResponse.num_deleted)
}

// -------------------------------------------------------------------

// ScanRequest

// optional .proto.RequestHeader header = 1;
inline bool ScanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& ScanRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.ScanRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* ScanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.ScanRequest.header)
  return header_;
}
inline ::proto::RequestHeader* ScanRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ScanRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ScanRequest.header)
}

// optional int64 max_results = 2;
inline bool ScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
inline ::google::protobuf::int64 ScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:proto.ScanRequest.max_results)
  return max_results_;
}
inline void ScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:proto.ScanRequest.max_results)
}

// -------------------------------------------------------------------

// ScanResponse

// optional .proto.ResponseHeader header = 1;
inline bool ScanResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& ScanResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.ScanResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* ScanResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.ScanResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* ScanResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ScanResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ScanResponse.header)
}

// repeated .proto.KeyValue rows = 2;
inline int ScanResponse::rows_size() const {
  return rows_.size();
}
inline void ScanResponse::clear_rows() {
  rows_.Clear();
}
inline const ::proto::KeyValue& ScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:proto.ScanResponse.rows)
  return rows_.Get(index);
}
inline ::proto::KeyValue* ScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ScanResponse.rows)
  return rows_.Mutable(index);
}
inline ::proto::KeyValue* ScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:proto.ScanResponse.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::KeyValue >&
ScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:proto.ScanResponse.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::KeyValue >*
ScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:proto.ScanResponse.rows)
  return &rows_;
}

// -------------------------------------------------------------------

// EndTransactionRequest

// optional .proto.RequestHeader header = 1;
inline bool EndTransactionRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndTransactionRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndTransactionRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndTransactionRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& EndTransactionRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.EndTransactionRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* EndTransactionRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.EndTransactionRequest.header)
  return header_;
}
inline ::proto::RequestHeader* EndTransactionRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EndTransactionRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EndTransactionRequest.header)
}

// optional bool commit = 2;
inline bool EndTransactionRequest::has_commit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndTransactionRequest::set_has_commit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndTransactionRequest::clear_has_commit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndTransactionRequest::clear_commit() {
  commit_ = false;
  clear_has_commit();
}
inline bool EndTransactionRequest::commit() const {
  // @@protoc_insertion_point(field_get:proto.EndTransactionRequest.commit)
  return commit_;
}
inline void EndTransactionRequest::set_commit(bool value) {
  set_has_commit();
  commit_ = value;
  // @@protoc_insertion_point(field_set:proto.EndTransactionRequest.commit)
}

// optional .proto.SplitTrigger split_trigger = 3;
inline bool EndTransactionRequest::has_split_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndTransactionRequest::set_has_split_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndTransactionRequest::clear_has_split_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndTransactionRequest::clear_split_trigger() {
  if (split_trigger_ != NULL) split_trigger_->::proto::SplitTrigger::Clear();
  clear_has_split_trigger();
}
inline const ::proto::SplitTrigger& EndTransactionRequest::split_trigger() const {
  // @@protoc_insertion_point(field_get:proto.EndTransactionRequest.split_trigger)
  return split_trigger_ != NULL ? *split_trigger_ : *default_instance_->split_trigger_;
}
inline ::proto::SplitTrigger* EndTransactionRequest::mutable_split_trigger() {
  set_has_split_trigger();
  if (split_trigger_ == NULL) split_trigger_ = new ::proto::SplitTrigger;
  // @@protoc_insertion_point(field_mutable:proto.EndTransactionRequest.split_trigger)
  return split_trigger_;
}
inline ::proto::SplitTrigger* EndTransactionRequest::release_split_trigger() {
  clear_has_split_trigger();
  ::proto::SplitTrigger* temp = split_trigger_;
  split_trigger_ = NULL;
  return temp;
}
inline void EndTransactionRequest::set_allocated_split_trigger(::proto::SplitTrigger* split_trigger) {
  delete split_trigger_;
  split_trigger_ = split_trigger;
  if (split_trigger) {
    set_has_split_trigger();
  } else {
    clear_has_split_trigger();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EndTransactionRequest.split_trigger)
}

// optional .proto.MergeTrigger merge_trigger = 4;
inline bool EndTransactionRequest::has_merge_trigger() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndTransactionRequest::set_has_merge_trigger() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndTransactionRequest::clear_has_merge_trigger() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndTransactionRequest::clear_merge_trigger() {
  if (merge_trigger_ != NULL) merge_trigger_->::proto::MergeTrigger::Clear();
  clear_has_merge_trigger();
}
inline const ::proto::MergeTrigger& EndTransactionRequest::merge_trigger() const {
  // @@protoc_insertion_point(field_get:proto.EndTransactionRequest.merge_trigger)
  return merge_trigger_ != NULL ? *merge_trigger_ : *default_instance_->merge_trigger_;
}
inline ::proto::MergeTrigger* EndTransactionRequest::mutable_merge_trigger() {
  set_has_merge_trigger();
  if (merge_trigger_ == NULL) merge_trigger_ = new ::proto::MergeTrigger;
  // @@protoc_insertion_point(field_mutable:proto.EndTransactionRequest.merge_trigger)
  return merge_trigger_;
}
inline ::proto::MergeTrigger* EndTransactionRequest::release_merge_trigger() {
  clear_has_merge_trigger();
  ::proto::MergeTrigger* temp = merge_trigger_;
  merge_trigger_ = NULL;
  return temp;
}
inline void EndTransactionRequest::set_allocated_merge_trigger(::proto::MergeTrigger* merge_trigger) {
  delete merge_trigger_;
  merge_trigger_ = merge_trigger;
  if (merge_trigger) {
    set_has_merge_trigger();
  } else {
    clear_has_merge_trigger();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EndTransactionRequest.merge_trigger)
}

// -------------------------------------------------------------------

// EndTransactionResponse

// optional .proto.ResponseHeader header = 1;
inline bool EndTransactionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndTransactionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndTransactionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndTransactionResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& EndTransactionResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.EndTransactionResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* EndTransactionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.EndTransactionResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* EndTransactionResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EndTransactionResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EndTransactionResponse.header)
}

// optional int64 commit_wait = 2;
inline bool EndTransactionResponse::has_commit_wait() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndTransactionResponse::set_has_commit_wait() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndTransactionResponse::clear_has_commit_wait() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndTransactionResponse::clear_commit_wait() {
  commit_wait_ = GOOGLE_LONGLONG(0);
  clear_has_commit_wait();
}
inline ::google::protobuf::int64 EndTransactionResponse::commit_wait() const {
  // @@protoc_insertion_point(field_get:proto.EndTransactionResponse.commit_wait)
  return commit_wait_;
}
inline void EndTransactionResponse::set_commit_wait(::google::protobuf::int64 value) {
  set_has_commit_wait();
  commit_wait_ = value;
  // @@protoc_insertion_point(field_set:proto.EndTransactionResponse.commit_wait)
}

// -------------------------------------------------------------------

// ReapQueueRequest

// optional .proto.RequestHeader header = 1;
inline bool ReapQueueRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReapQueueRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReapQueueRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReapQueueRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& ReapQueueRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.ReapQueueRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* ReapQueueRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.ReapQueueRequest.header)
  return header_;
}
inline ::proto::RequestHeader* ReapQueueRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReapQueueRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReapQueueRequest.header)
}

// optional int64 max_results = 2;
inline bool ReapQueueRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReapQueueRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReapQueueRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReapQueueRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
inline ::google::protobuf::int64 ReapQueueRequest::max_results() const {
  // @@protoc_insertion_point(field_get:proto.ReapQueueRequest.max_results)
  return max_results_;
}
inline void ReapQueueRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:proto.ReapQueueRequest.max_results)
}

// -------------------------------------------------------------------

// ReapQueueResponse

// optional .proto.ResponseHeader header = 1;
inline bool ReapQueueResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReapQueueResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReapQueueResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReapQueueResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& ReapQueueResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.ReapQueueResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* ReapQueueResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.ReapQueueResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* ReapQueueResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReapQueueResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ReapQueueResponse.header)
}

// repeated .proto.Value messages = 2;
inline int ReapQueueResponse::messages_size() const {
  return messages_.size();
}
inline void ReapQueueResponse::clear_messages() {
  messages_.Clear();
}
inline const ::proto::Value& ReapQueueResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:proto.ReapQueueResponse.messages)
  return messages_.Get(index);
}
inline ::proto::Value* ReapQueueResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ReapQueueResponse.messages)
  return messages_.Mutable(index);
}
inline ::proto::Value* ReapQueueResponse::add_messages() {
  // @@protoc_insertion_point(field_add:proto.ReapQueueResponse.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Value >&
ReapQueueResponse::messages() const {
  // @@protoc_insertion_point(field_list:proto.ReapQueueResponse.messages)
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Value >*
ReapQueueResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:proto.ReapQueueResponse.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// EnqueueUpdateRequest

// optional .proto.RequestHeader header = 1;
inline bool EnqueueUpdateRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnqueueUpdateRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnqueueUpdateRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnqueueUpdateRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& EnqueueUpdateRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.EnqueueUpdateRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* EnqueueUpdateRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.EnqueueUpdateRequest.header)
  return header_;
}
inline ::proto::RequestHeader* EnqueueUpdateRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EnqueueUpdateRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EnqueueUpdateRequest.header)
}

// -------------------------------------------------------------------

// EnqueueUpdateResponse

// optional .proto.ResponseHeader header = 1;
inline bool EnqueueUpdateResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnqueueUpdateResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnqueueUpdateResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnqueueUpdateResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& EnqueueUpdateResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.EnqueueUpdateResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* EnqueueUpdateResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.EnqueueUpdateResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* EnqueueUpdateResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EnqueueUpdateResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EnqueueUpdateResponse.header)
}

// -------------------------------------------------------------------

// EnqueueMessageRequest

// optional .proto.RequestHeader header = 1;
inline bool EnqueueMessageRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnqueueMessageRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnqueueMessageRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnqueueMessageRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& EnqueueMessageRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.EnqueueMessageRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* EnqueueMessageRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.EnqueueMessageRequest.header)
  return header_;
}
inline ::proto::RequestHeader* EnqueueMessageRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EnqueueMessageRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EnqueueMessageRequest.header)
}

// optional .proto.Value msg = 2;
inline bool EnqueueMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnqueueMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnqueueMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnqueueMessageRequest::clear_msg() {
  if (msg_ != NULL) msg_->::proto::Value::Clear();
  clear_has_msg();
}
inline const ::proto::Value& EnqueueMessageRequest::msg() const {
  // @@protoc_insertion_point(field_get:proto.EnqueueMessageRequest.msg)
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::proto::Value* EnqueueMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::proto::Value;
  // @@protoc_insertion_point(field_mutable:proto.EnqueueMessageRequest.msg)
  return msg_;
}
inline ::proto::Value* EnqueueMessageRequest::release_msg() {
  clear_has_msg();
  ::proto::Value* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void EnqueueMessageRequest::set_allocated_msg(::proto::Value* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EnqueueMessageRequest.msg)
}

// -------------------------------------------------------------------

// EnqueueMessageResponse

// optional .proto.ResponseHeader header = 1;
inline bool EnqueueMessageResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnqueueMessageResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnqueueMessageResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnqueueMessageResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& EnqueueMessageResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.EnqueueMessageResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* EnqueueMessageResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.EnqueueMessageResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* EnqueueMessageResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EnqueueMessageResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.EnqueueMessageResponse.header)
}

// -------------------------------------------------------------------

// RequestUnion

// optional .proto.ContainsRequest contains = 1;
inline bool RequestUnion::has_contains() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUnion::set_has_contains() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUnion::clear_has_contains() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUnion::clear_contains() {
  if (contains_ != NULL) contains_->::proto::ContainsRequest::Clear();
  clear_has_contains();
}
inline const ::proto::ContainsRequest& RequestUnion::contains() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.contains)
  return contains_ != NULL ? *contains_ : *default_instance_->contains_;
}
inline ::proto::ContainsRequest* RequestUnion::mutable_contains() {
  set_has_contains();
  if (contains_ == NULL) contains_ = new ::proto::ContainsRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.contains)
  return contains_;
}
inline ::proto::ContainsRequest* RequestUnion::release_contains() {
  clear_has_contains();
  ::proto::ContainsRequest* temp = contains_;
  contains_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_contains(::proto::ContainsRequest* contains) {
  delete contains_;
  contains_ = contains;
  if (contains) {
    set_has_contains();
  } else {
    clear_has_contains();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.contains)
}

// optional .proto.GetRequest get = 2;
inline bool RequestUnion::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUnion::set_has_get() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUnion::clear_get() {
  if (get_ != NULL) get_->::proto::GetRequest::Clear();
  clear_has_get();
}
inline const ::proto::GetRequest& RequestUnion::get() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::proto::GetRequest* RequestUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) get_ = new ::proto::GetRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.get)
  return get_;
}
inline ::proto::GetRequest* RequestUnion::release_get() {
  clear_has_get();
  ::proto::GetRequest* temp = get_;
  get_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_get(::proto::GetRequest* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.get)
}

// optional .proto.PutRequest put = 3;
inline bool RequestUnion::has_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUnion::set_has_put() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUnion::clear_put() {
  if (put_ != NULL) put_->::proto::PutRequest::Clear();
  clear_has_put();
}
inline const ::proto::PutRequest& RequestUnion::put() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::proto::PutRequest* RequestUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) put_ = new ::proto::PutRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.put)
  return put_;
}
inline ::proto::PutRequest* RequestUnion::release_put() {
  clear_has_put();
  ::proto::PutRequest* temp = put_;
  put_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_put(::proto::PutRequest* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.put)
}

// optional .proto.ConditionalPutRequest conditional_put = 4;
inline bool RequestUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::proto::ConditionalPutRequest::Clear();
  clear_has_conditional_put();
}
inline const ::proto::ConditionalPutRequest& RequestUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
inline ::proto::ConditionalPutRequest* RequestUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) conditional_put_ = new ::proto::ConditionalPutRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.conditional_put)
  return conditional_put_;
}
inline ::proto::ConditionalPutRequest* RequestUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::proto::ConditionalPutRequest* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_conditional_put(::proto::ConditionalPutRequest* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.conditional_put)
}

// optional .proto.IncrementRequest increment = 5;
inline bool RequestUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestUnion::clear_increment() {
  if (increment_ != NULL) increment_->::proto::IncrementRequest::Clear();
  clear_has_increment();
}
inline const ::proto::IncrementRequest& RequestUnion::increment() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
inline ::proto::IncrementRequest* RequestUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) increment_ = new ::proto::IncrementRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.increment)
  return increment_;
}
inline ::proto::IncrementRequest* RequestUnion::release_increment() {
  clear_has_increment();
  ::proto::IncrementRequest* temp = increment_;
  increment_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_increment(::proto::IncrementRequest* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.increment)
}

// optional .proto.DeleteRequest delete = 6;
inline bool RequestUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::proto::DeleteRequest::Clear();
  clear_has_delete_();
}
inline const ::proto::DeleteRequest& RequestUnion::delete_() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::proto::DeleteRequest* RequestUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) delete__ = new ::proto::DeleteRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.delete)
  return delete__;
}
inline ::proto::DeleteRequest* RequestUnion::release_delete_() {
  clear_has_delete_();
  ::proto::DeleteRequest* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_delete_(::proto::DeleteRequest* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.delete)
}

// optional .proto.DeleteRangeRequest delete_range = 7;
inline bool RequestUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::proto::DeleteRangeRequest::Clear();
  clear_has_delete_range();
}
inline const ::proto::DeleteRangeRequest& RequestUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
inline ::proto::DeleteRangeRequest* RequestUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) delete_range_ = new ::proto::DeleteRangeRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.delete_range)
  return delete_range_;
}
inline ::proto::DeleteRangeRequest* RequestUnion::release_delete_range() {
  clear_has_delete_range();
  ::proto::DeleteRangeRequest* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_delete_range(::proto::DeleteRangeRequest* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.delete_range)
}

// optional .proto.ScanRequest scan = 8;
inline bool RequestUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestUnion::clear_scan() {
  if (scan_ != NULL) scan_->::proto::ScanRequest::Clear();
  clear_has_scan();
}
inline const ::proto::ScanRequest& RequestUnion::scan() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::proto::ScanRequest* RequestUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) scan_ = new ::proto::ScanRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.scan)
  return scan_;
}
inline ::proto::ScanRequest* RequestUnion::release_scan() {
  clear_has_scan();
  ::proto::ScanRequest* temp = scan_;
  scan_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_scan(::proto::ScanRequest* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.scan)
}

// optional .proto.EndTransactionRequest end_transaction = 9;
inline bool RequestUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::proto::EndTransactionRequest::Clear();
  clear_has_end_transaction();
}
inline const ::proto::EndTransactionRequest& RequestUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
inline ::proto::EndTransactionRequest* RequestUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) end_transaction_ = new ::proto::EndTransactionRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.end_transaction)
  return end_transaction_;
}
inline ::proto::EndTransactionRequest* RequestUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::proto::EndTransactionRequest* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_end_transaction(::proto::EndTransactionRequest* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.end_transaction)
}

// optional .proto.ReapQueueRequest reap_queue = 10;
inline bool RequestUnion::has_reap_queue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RequestUnion::set_has_reap_queue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RequestUnion::clear_has_reap_queue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RequestUnion::clear_reap_queue() {
  if (reap_queue_ != NULL) reap_queue_->::proto::ReapQueueRequest::Clear();
  clear_has_reap_queue();
}
inline const ::proto::ReapQueueRequest& RequestUnion::reap_queue() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.reap_queue)
  return reap_queue_ != NULL ? *reap_queue_ : *default_instance_->reap_queue_;
}
inline ::proto::ReapQueueRequest* RequestUnion::mutable_reap_queue() {
  set_has_reap_queue();
  if (reap_queue_ == NULL) reap_queue_ = new ::proto::ReapQueueRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.reap_queue)
  return reap_queue_;
}
inline ::proto::ReapQueueRequest* RequestUnion::release_reap_queue() {
  clear_has_reap_queue();
  ::proto::ReapQueueRequest* temp = reap_queue_;
  reap_queue_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_reap_queue(::proto::ReapQueueRequest* reap_queue) {
  delete reap_queue_;
  reap_queue_ = reap_queue;
  if (reap_queue) {
    set_has_reap_queue();
  } else {
    clear_has_reap_queue();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.reap_queue)
}

// optional .proto.EnqueueUpdateRequest enqueue_update = 11;
inline bool RequestUnion::has_enqueue_update() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RequestUnion::set_has_enqueue_update() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RequestUnion::clear_has_enqueue_update() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RequestUnion::clear_enqueue_update() {
  if (enqueue_update_ != NULL) enqueue_update_->::proto::EnqueueUpdateRequest::Clear();
  clear_has_enqueue_update();
}
inline const ::proto::EnqueueUpdateRequest& RequestUnion::enqueue_update() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.enqueue_update)
  return enqueue_update_ != NULL ? *enqueue_update_ : *default_instance_->enqueue_update_;
}
inline ::proto::EnqueueUpdateRequest* RequestUnion::mutable_enqueue_update() {
  set_has_enqueue_update();
  if (enqueue_update_ == NULL) enqueue_update_ = new ::proto::EnqueueUpdateRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.enqueue_update)
  return enqueue_update_;
}
inline ::proto::EnqueueUpdateRequest* RequestUnion::release_enqueue_update() {
  clear_has_enqueue_update();
  ::proto::EnqueueUpdateRequest* temp = enqueue_update_;
  enqueue_update_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_enqueue_update(::proto::EnqueueUpdateRequest* enqueue_update) {
  delete enqueue_update_;
  enqueue_update_ = enqueue_update;
  if (enqueue_update) {
    set_has_enqueue_update();
  } else {
    clear_has_enqueue_update();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.enqueue_update)
}

// optional .proto.EnqueueMessageRequest enqueue_message = 12;
inline bool RequestUnion::has_enqueue_message() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RequestUnion::set_has_enqueue_message() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RequestUnion::clear_has_enqueue_message() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RequestUnion::clear_enqueue_message() {
  if (enqueue_message_ != NULL) enqueue_message_->::proto::EnqueueMessageRequest::Clear();
  clear_has_enqueue_message();
}
inline const ::proto::EnqueueMessageRequest& RequestUnion::enqueue_message() const {
  // @@protoc_insertion_point(field_get:proto.RequestUnion.enqueue_message)
  return enqueue_message_ != NULL ? *enqueue_message_ : *default_instance_->enqueue_message_;
}
inline ::proto::EnqueueMessageRequest* RequestUnion::mutable_enqueue_message() {
  set_has_enqueue_message();
  if (enqueue_message_ == NULL) enqueue_message_ = new ::proto::EnqueueMessageRequest;
  // @@protoc_insertion_point(field_mutable:proto.RequestUnion.enqueue_message)
  return enqueue_message_;
}
inline ::proto::EnqueueMessageRequest* RequestUnion::release_enqueue_message() {
  clear_has_enqueue_message();
  ::proto::EnqueueMessageRequest* temp = enqueue_message_;
  enqueue_message_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_enqueue_message(::proto::EnqueueMessageRequest* enqueue_message) {
  delete enqueue_message_;
  enqueue_message_ = enqueue_message;
  if (enqueue_message) {
    set_has_enqueue_message();
  } else {
    clear_has_enqueue_message();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RequestUnion.enqueue_message)
}

// -------------------------------------------------------------------

// ResponseUnion

// optional .proto.ContainsResponse contains = 1;
inline bool ResponseUnion::has_contains() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUnion::set_has_contains() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUnion::clear_has_contains() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUnion::clear_contains() {
  if (contains_ != NULL) contains_->::proto::ContainsResponse::Clear();
  clear_has_contains();
}
inline const ::proto::ContainsResponse& ResponseUnion::contains() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.contains)
  return contains_ != NULL ? *contains_ : *default_instance_->contains_;
}
inline ::proto::ContainsResponse* ResponseUnion::mutable_contains() {
  set_has_contains();
  if (contains_ == NULL) contains_ = new ::proto::ContainsResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.contains)
  return contains_;
}
inline ::proto::ContainsResponse* ResponseUnion::release_contains() {
  clear_has_contains();
  ::proto::ContainsResponse* temp = contains_;
  contains_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_contains(::proto::ContainsResponse* contains) {
  delete contains_;
  contains_ = contains;
  if (contains) {
    set_has_contains();
  } else {
    clear_has_contains();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.contains)
}

// optional .proto.GetResponse get = 2;
inline bool ResponseUnion::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseUnion::set_has_get() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseUnion::clear_get() {
  if (get_ != NULL) get_->::proto::GetResponse::Clear();
  clear_has_get();
}
inline const ::proto::GetResponse& ResponseUnion::get() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::proto::GetResponse* ResponseUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) get_ = new ::proto::GetResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.get)
  return get_;
}
inline ::proto::GetResponse* ResponseUnion::release_get() {
  clear_has_get();
  ::proto::GetResponse* temp = get_;
  get_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_get(::proto::GetResponse* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.get)
}

// optional .proto.PutResponse put = 3;
inline bool ResponseUnion::has_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseUnion::set_has_put() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseUnion::clear_put() {
  if (put_ != NULL) put_->::proto::PutResponse::Clear();
  clear_has_put();
}
inline const ::proto::PutResponse& ResponseUnion::put() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::proto::PutResponse* ResponseUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) put_ = new ::proto::PutResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.put)
  return put_;
}
inline ::proto::PutResponse* ResponseUnion::release_put() {
  clear_has_put();
  ::proto::PutResponse* temp = put_;
  put_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_put(::proto::PutResponse* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.put)
}

// optional .proto.ConditionalPutResponse conditional_put = 4;
inline bool ResponseUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::proto::ConditionalPutResponse::Clear();
  clear_has_conditional_put();
}
inline const ::proto::ConditionalPutResponse& ResponseUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
inline ::proto::ConditionalPutResponse* ResponseUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) conditional_put_ = new ::proto::ConditionalPutResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.conditional_put)
  return conditional_put_;
}
inline ::proto::ConditionalPutResponse* ResponseUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::proto::ConditionalPutResponse* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_conditional_put(::proto::ConditionalPutResponse* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.conditional_put)
}

// optional .proto.IncrementResponse increment = 5;
inline bool ResponseUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseUnion::clear_increment() {
  if (increment_ != NULL) increment_->::proto::IncrementResponse::Clear();
  clear_has_increment();
}
inline const ::proto::IncrementResponse& ResponseUnion::increment() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
inline ::proto::IncrementResponse* ResponseUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) increment_ = new ::proto::IncrementResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.increment)
  return increment_;
}
inline ::proto::IncrementResponse* ResponseUnion::release_increment() {
  clear_has_increment();
  ::proto::IncrementResponse* temp = increment_;
  increment_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_increment(::proto::IncrementResponse* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.increment)
}

// optional .proto.DeleteResponse delete = 6;
inline bool ResponseUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::proto::DeleteResponse::Clear();
  clear_has_delete_();
}
inline const ::proto::DeleteResponse& ResponseUnion::delete_() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::proto::DeleteResponse* ResponseUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) delete__ = new ::proto::DeleteResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.delete)
  return delete__;
}
inline ::proto::DeleteResponse* ResponseUnion::release_delete_() {
  clear_has_delete_();
  ::proto::DeleteResponse* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_delete_(::proto::DeleteResponse* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.delete)
}

// optional .proto.DeleteRangeResponse delete_range = 7;
inline bool ResponseUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::proto::DeleteRangeResponse::Clear();
  clear_has_delete_range();
}
inline const ::proto::DeleteRangeResponse& ResponseUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
inline ::proto::DeleteRangeResponse* ResponseUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) delete_range_ = new ::proto::DeleteRangeResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.delete_range)
  return delete_range_;
}
inline ::proto::DeleteRangeResponse* ResponseUnion::release_delete_range() {
  clear_has_delete_range();
  ::proto::DeleteRangeResponse* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_delete_range(::proto::DeleteRangeResponse* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.delete_range)
}

// optional .proto.ScanResponse scan = 8;
inline bool ResponseUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseUnion::clear_scan() {
  if (scan_ != NULL) scan_->::proto::ScanResponse::Clear();
  clear_has_scan();
}
inline const ::proto::ScanResponse& ResponseUnion::scan() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::proto::ScanResponse* ResponseUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) scan_ = new ::proto::ScanResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.scan)
  return scan_;
}
inline ::proto::ScanResponse* ResponseUnion::release_scan() {
  clear_has_scan();
  ::proto::ScanResponse* temp = scan_;
  scan_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_scan(::proto::ScanResponse* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.scan)
}

// optional .proto.EndTransactionResponse end_transaction = 9;
inline bool ResponseUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::proto::EndTransactionResponse::Clear();
  clear_has_end_transaction();
}
inline const ::proto::EndTransactionResponse& ResponseUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
inline ::proto::EndTransactionResponse* ResponseUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) end_transaction_ = new ::proto::EndTransactionResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.end_transaction)
  return end_transaction_;
}
inline ::proto::EndTransactionResponse* ResponseUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::proto::EndTransactionResponse* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_end_transaction(::proto::EndTransactionResponse* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.end_transaction)
}

// optional .proto.ReapQueueResponse reap_queue = 10;
inline bool ResponseUnion::has_reap_queue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseUnion::set_has_reap_queue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseUnion::clear_has_reap_queue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseUnion::clear_reap_queue() {
  if (reap_queue_ != NULL) reap_queue_->::proto::ReapQueueResponse::Clear();
  clear_has_reap_queue();
}
inline const ::proto::ReapQueueResponse& ResponseUnion::reap_queue() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.reap_queue)
  return reap_queue_ != NULL ? *reap_queue_ : *default_instance_->reap_queue_;
}
inline ::proto::ReapQueueResponse* ResponseUnion::mutable_reap_queue() {
  set_has_reap_queue();
  if (reap_queue_ == NULL) reap_queue_ = new ::proto::ReapQueueResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.reap_queue)
  return reap_queue_;
}
inline ::proto::ReapQueueResponse* ResponseUnion::release_reap_queue() {
  clear_has_reap_queue();
  ::proto::ReapQueueResponse* temp = reap_queue_;
  reap_queue_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_reap_queue(::proto::ReapQueueResponse* reap_queue) {
  delete reap_queue_;
  reap_queue_ = reap_queue;
  if (reap_queue) {
    set_has_reap_queue();
  } else {
    clear_has_reap_queue();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.reap_queue)
}

// optional .proto.EnqueueUpdateResponse enqueue_update = 11;
inline bool ResponseUnion::has_enqueue_update() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseUnion::set_has_enqueue_update() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseUnion::clear_has_enqueue_update() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseUnion::clear_enqueue_update() {
  if (enqueue_update_ != NULL) enqueue_update_->::proto::EnqueueUpdateResponse::Clear();
  clear_has_enqueue_update();
}
inline const ::proto::EnqueueUpdateResponse& ResponseUnion::enqueue_update() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.enqueue_update)
  return enqueue_update_ != NULL ? *enqueue_update_ : *default_instance_->enqueue_update_;
}
inline ::proto::EnqueueUpdateResponse* ResponseUnion::mutable_enqueue_update() {
  set_has_enqueue_update();
  if (enqueue_update_ == NULL) enqueue_update_ = new ::proto::EnqueueUpdateResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.enqueue_update)
  return enqueue_update_;
}
inline ::proto::EnqueueUpdateResponse* ResponseUnion::release_enqueue_update() {
  clear_has_enqueue_update();
  ::proto::EnqueueUpdateResponse* temp = enqueue_update_;
  enqueue_update_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_enqueue_update(::proto::EnqueueUpdateResponse* enqueue_update) {
  delete enqueue_update_;
  enqueue_update_ = enqueue_update;
  if (enqueue_update) {
    set_has_enqueue_update();
  } else {
    clear_has_enqueue_update();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.enqueue_update)
}

// optional .proto.EnqueueMessageResponse enqueue_message = 12;
inline bool ResponseUnion::has_enqueue_message() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseUnion::set_has_enqueue_message() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseUnion::clear_has_enqueue_message() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseUnion::clear_enqueue_message() {
  if (enqueue_message_ != NULL) enqueue_message_->::proto::EnqueueMessageResponse::Clear();
  clear_has_enqueue_message();
}
inline const ::proto::EnqueueMessageResponse& ResponseUnion::enqueue_message() const {
  // @@protoc_insertion_point(field_get:proto.ResponseUnion.enqueue_message)
  return enqueue_message_ != NULL ? *enqueue_message_ : *default_instance_->enqueue_message_;
}
inline ::proto::EnqueueMessageResponse* ResponseUnion::mutable_enqueue_message() {
  set_has_enqueue_message();
  if (enqueue_message_ == NULL) enqueue_message_ = new ::proto::EnqueueMessageResponse;
  // @@protoc_insertion_point(field_mutable:proto.ResponseUnion.enqueue_message)
  return enqueue_message_;
}
inline ::proto::EnqueueMessageResponse* ResponseUnion::release_enqueue_message() {
  clear_has_enqueue_message();
  ::proto::EnqueueMessageResponse* temp = enqueue_message_;
  enqueue_message_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_enqueue_message(::proto::EnqueueMessageResponse* enqueue_message) {
  delete enqueue_message_;
  enqueue_message_ = enqueue_message;
  if (enqueue_message) {
    set_has_enqueue_message();
  } else {
    clear_has_enqueue_message();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ResponseUnion.enqueue_message)
}

// -------------------------------------------------------------------

// BatchRequest

// optional .proto.RequestHeader header = 1;
inline bool BatchRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& BatchRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.BatchRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* BatchRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.BatchRequest.header)
  return header_;
}
inline ::proto::RequestHeader* BatchRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BatchRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.BatchRequest.header)
}

// repeated .proto.RequestUnion requests = 2;
inline int BatchRequest::requests_size() const {
  return requests_.size();
}
inline void BatchRequest::clear_requests() {
  requests_.Clear();
}
inline const ::proto::RequestUnion& BatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:proto.BatchRequest.requests)
  return requests_.Get(index);
}
inline ::proto::RequestUnion* BatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:proto.BatchRequest.requests)
  return requests_.Mutable(index);
}
inline ::proto::RequestUnion* BatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:proto.BatchRequest.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::RequestUnion >&
BatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:proto.BatchRequest.requests)
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::RequestUnion >*
BatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:proto.BatchRequest.requests)
  return &requests_;
}

// -------------------------------------------------------------------

// BatchResponse

// optional .proto.ResponseHeader header = 1;
inline bool BatchResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& BatchResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.BatchResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* BatchResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.BatchResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* BatchResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BatchResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.BatchResponse.header)
}

// repeated .proto.ResponseUnion responses = 2;
inline int BatchResponse::responses_size() const {
  return responses_.size();
}
inline void BatchResponse::clear_responses() {
  responses_.Clear();
}
inline const ::proto::ResponseUnion& BatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:proto.BatchResponse.responses)
  return responses_.Get(index);
}
inline ::proto::ResponseUnion* BatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:proto.BatchResponse.responses)
  return responses_.Mutable(index);
}
inline ::proto::ResponseUnion* BatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:proto.BatchResponse.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::ResponseUnion >&
BatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:proto.BatchResponse.responses)
  return responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::ResponseUnion >*
BatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:proto.BatchResponse.responses)
  return &responses_;
}

// -------------------------------------------------------------------

// AdminSplitRequest

// optional .proto.RequestHeader header = 1;
inline bool AdminSplitRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminSplitRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminSplitRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminSplitRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& AdminSplitRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.AdminSplitRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* AdminSplitRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.AdminSplitRequest.header)
  return header_;
}
inline ::proto::RequestHeader* AdminSplitRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminSplitRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminSplitRequest.header)
}

// optional bytes split_key = 2;
inline bool AdminSplitRequest::has_split_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminSplitRequest::set_has_split_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminSplitRequest::clear_has_split_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminSplitRequest::clear_split_key() {
  if (split_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    split_key_->clear();
  }
  clear_has_split_key();
}
inline const ::std::string& AdminSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:proto.AdminSplitRequest.split_key)
  return *split_key_;
}
inline void AdminSplitRequest::set_split_key(const ::std::string& value) {
  set_has_split_key();
  if (split_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    split_key_ = new ::std::string;
  }
  split_key_->assign(value);
  // @@protoc_insertion_point(field_set:proto.AdminSplitRequest.split_key)
}
inline void AdminSplitRequest::set_split_key(const char* value) {
  set_has_split_key();
  if (split_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    split_key_ = new ::std::string;
  }
  split_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.AdminSplitRequest.split_key)
}
inline void AdminSplitRequest::set_split_key(const void* value, size_t size) {
  set_has_split_key();
  if (split_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    split_key_ = new ::std::string;
  }
  split_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.AdminSplitRequest.split_key)
}
inline ::std::string* AdminSplitRequest::mutable_split_key() {
  set_has_split_key();
  if (split_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    split_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:proto.AdminSplitRequest.split_key)
  return split_key_;
}
inline ::std::string* AdminSplitRequest::release_split_key() {
  clear_has_split_key();
  if (split_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = split_key_;
    split_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AdminSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete split_key_;
  }
  if (split_key) {
    set_has_split_key();
    split_key_ = split_key;
  } else {
    clear_has_split_key();
    split_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminSplitRequest.split_key)
}

// -------------------------------------------------------------------

// AdminSplitResponse

// optional .proto.ResponseHeader header = 1;
inline bool AdminSplitResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminSplitResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminSplitResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminSplitResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& AdminSplitResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.AdminSplitResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* AdminSplitResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.AdminSplitResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* AdminSplitResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminSplitResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminSplitResponse.header)
}

// -------------------------------------------------------------------

// AdminMergeRequest

// optional .proto.RequestHeader header = 1;
inline bool AdminMergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminMergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminMergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminMergeRequest::clear_header() {
  if (header_ != NULL) header_->::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::proto::RequestHeader& AdminMergeRequest::header() const {
  // @@protoc_insertion_point(field_get:proto.AdminMergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::RequestHeader* AdminMergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:proto.AdminMergeRequest.header)
  return header_;
}
inline ::proto::RequestHeader* AdminMergeRequest::release_header() {
  clear_has_header();
  ::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminMergeRequest::set_allocated_header(::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminMergeRequest.header)
}

// optional .proto.RangeDescriptor subsumed_range = 2;
inline bool AdminMergeRequest::has_subsumed_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminMergeRequest::set_has_subsumed_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminMergeRequest::clear_has_subsumed_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminMergeRequest::clear_subsumed_range() {
  if (subsumed_range_ != NULL) subsumed_range_->::proto::RangeDescriptor::Clear();
  clear_has_subsumed_range();
}
inline const ::proto::RangeDescriptor& AdminMergeRequest::subsumed_range() const {
  // @@protoc_insertion_point(field_get:proto.AdminMergeRequest.subsumed_range)
  return subsumed_range_ != NULL ? *subsumed_range_ : *default_instance_->subsumed_range_;
}
inline ::proto::RangeDescriptor* AdminMergeRequest::mutable_subsumed_range() {
  set_has_subsumed_range();
  if (subsumed_range_ == NULL) subsumed_range_ = new ::proto::RangeDescriptor;
  // @@protoc_insertion_point(field_mutable:proto.AdminMergeRequest.subsumed_range)
  return subsumed_range_;
}
inline ::proto::RangeDescriptor* AdminMergeRequest::release_subsumed_range() {
  clear_has_subsumed_range();
  ::proto::RangeDescriptor* temp = subsumed_range_;
  subsumed_range_ = NULL;
  return temp;
}
inline void AdminMergeRequest::set_allocated_subsumed_range(::proto::RangeDescriptor* subsumed_range) {
  delete subsumed_range_;
  subsumed_range_ = subsumed_range;
  if (subsumed_range) {
    set_has_subsumed_range();
  } else {
    clear_has_subsumed_range();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminMergeRequest.subsumed_range)
}

// -------------------------------------------------------------------

// AdminMergeResponse

// optional .proto.ResponseHeader header = 1;
inline bool AdminMergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminMergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminMergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminMergeResponse::clear_header() {
  if (header_ != NULL) header_->::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::proto::ResponseHeader& AdminMergeResponse::header() const {
  // @@protoc_insertion_point(field_get:proto.AdminMergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::proto::ResponseHeader* AdminMergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:proto.AdminMergeResponse.header)
  return header_;
}
inline ::proto::ResponseHeader* AdminMergeResponse::release_header() {
  clear_has_header();
  ::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminMergeResponse::set_allocated_header(::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminMergeResponse.header)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2eproto__INCLUDED
